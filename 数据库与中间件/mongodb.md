## 常识问题
1. 你对NoSQL数据库有什么了解？ MongoDB是NoSQL数据库吗？ 请说明。
   - NoSQL, NoSQL is not SQL
   - NoSQL是对SQL的补充，SQL的缺点是表比较固化;事务属性强，锁开销导致写性能低;磁盘型数据库
   - NoSQL有很多类型，从各个方面去补充SQL缺点。有KV型，文档型，列型，图型
   - MongoDB是NoSQL数据库，它是文档型的
2. MongoDB支持哪些语言？
   - MonggoDB为C，C ++，C＃，Java，Node.js，Perl，PHP，Python，Ruby，Scala，Go和Erlang提供官方驱动程序支持。 可以将MongoDB与上述任何语言一起使用。 还有一些其他社区支持的驱动程序，但上面提到的驱动程序由MongoDB正式提供
3. NoSQL数据库有哪些不同类型？ 请例举说明。   
   - NoSQL数据库可分为4种基本类型：
   - 键值kv存储。redis
   - 文档存储。MongoDB，ElasticSearch,CouchBD,Couchbase
   - 列存储。Hbase,Cassandra
   - 图形库.
   - [NoSQL概述-从Mongo和Cassandra谈谈NoSQL](https://cloud.tencent.com/developer/article/1480386)
    - [数据库排名](https://db-engines.com/en/ranking)

数据模型 | 相关数据库 | 典型应用 | 优 势|劣势 
---|---|---|---|---
key-value|Redis|缓存|快速查询|存储数据缺乏结构化
列族|Cassandra,Hbase|分布式的文件系统，大规模的数据存储|易于分布式扩展|功能受限
document|Mongo,CouchDB||free-schema|可扩展性查
图|Neo4J|社交网络|利用图结构相关算法|不易扩展
    
4. mongoDB的基本结构
   - MongoDB的最基本的数据单元，叫document，类似于关系式数据库中的行row。一系列documents，组成了一个collection，相当于关系式数据库中的table。当一个 collection 数据量太大时，可以把该collection按documents切分，分成多个数据块，每个数据块叫做一个chunk，多个chunks聚集在一起，组成了一个shard
   - Sharding 的意义，不仅保障了数据库的扩容（scalability），同时也保障了系统的负载均衡（load balance）

4. MongoDB比其他SQL数据库更好吗？ 如果是，那怎么个好法？
   - 每种数据库都有各自的特点和适用的场景，没有谁一定比谁好的说法
   - MongoDB的主要优点是灵活的文档型结构，支持复制集和自动故障转移，支持自动分片。支持索引以快速查询。
6. MongoDB和MySQL有什么区别？
   - MySQL支持事务，表结构型数据库，不支持自动分片
   - MongoDB不支持事务，灵活的文档型数据库，支持自动分片和主从故障转移。不支持join，所以只适合数据内聚的业务，不适合有很多join操作。
8. MongoDB是否支持主键，外键关系？
   - 不支持，需要由业务逻辑来实现主键和外键

11. 解释MongoDB中ObjectID的结构。
    - 12个字节。时间戳(4)+机器码(3)+进程号(2)+自增序列(3)
    - elastic的ID。20字节。由fakeID算法生成的20字节UUID
    - snowflake的ID。8字节。1bit+时间戳(41bit)+机器ID(10bit)+自增序列(12bit)
12. MongoDB是使用BSON来表示文档结构？
    - 是的。
    - BSON是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型
    - BSON可以做为网络数据交换的一种存储形式，这个有点类似于Google的Protocol Buffer，但是BSON是一种schema-less的存储形式，它的优点是灵活性高，但它的缺点是空间利用率不是很理想，
15. MongoDB中的命名空间是什么？
    - MongoDB每个集合和每个索引都对应一个命名空间，这些命名空间的元数据集中在16M的*.ns文件中，平均每个命名占用约 628 字节，也即整个数据库的命名空间的上限约为24000
    - 如果每个集合有一个索引（比如默认的_id索引），那么最多可以创建12000个集合。如果索引数更多，则可创建的集合数就更少了。同时，如果集合数太多，一些操作也会变慢。
    - 要建立更多的集合的话，MongoDB 也是支持的，只需要在启动时加上“--nssize”参数，这样对应数据库的命名空间文件就可以变得更大以便保存更多的命名。这个命名空间文件（.ns文件）最大可以为 2G
19. MongoDB使用哪种语言编写？
    - C++
26. 为什么32位版本的MongoDB不是首选版本？
    - 因为MongoDB使用内存映射文件，因此当运行32位版本的MongoDB时，服务器的总存储大小为2GB。但是，当运行64位版本的MongoDB时，这提供了几乎无限的存储大小。 因此，64位优先于32位。
44. MongoDB和Redis数据库有什么区别？
    - MongoDB：文档型数据库，数据存在磁盘，支持索引，有索引缓存在内存加快查询。支持自动分片。支持主从自动故障迁移。不支持事务
    - Redis：KV型数据库，数据主要全部放在内存（可以持久化）。通过槽手动分片。支持主从自动故障迁移。不支持事务
45. MongoDB和CouchDB有什么区别？
    - [MongoDB与CouchDB全方位对比](https://blog.51cto.com/gnucto/1218729)
46. MongoDB和Cassandra有什么区别？
    - Cassandra可以处理最庞大的数据集。Instagram每天平均处理8000万张照片，而Spotify则在其数据库中存储超过2000万首歌曲。Cassandra有这令人惊讶的可靠性，Cassandra使用点对点容错技术，无主/从设置，故障转移或领导者选举。这意味着可以委派群集中的任何节点，以便在发生故障时执行查询。最终的一致性产生高可用。cassandra倾向于降低一致性。它是“最终一致的”，用于设置数据库一致性模型。最终的一致性可以实现高可用性，而不是保持强一致性，从而实现更低的延时，更高的可用性，而不是立即向所有服务器上同步数据。扩容时最小化管理任务
    - mongoDB。文档型数据库，提供令人叹为观止的灵活性，高性能，高可用，自动扩容。
    - Cassandra相对简约，mongoDB功能更加强大，强大的查询能力。因为模型扩展性好，能更快尝试新东西
    - [cassandra vs mongoDB in 2019,如何选型](https://yq.aliyun.com/articles/713850)
7. MongoDB的一些默认参数
   - MongoDB默认存储数据目录为/data/db，默认端口为27017，默认HTTP端口为28017
8. MongoDB支持存储过程吗？如果支持的话，怎么用？
   - MongoDB支持存储过程，它是JavaScript写的，保存在db.system.js表中。
9. mongo使用场景
   - 在处理非结构化/半结构化的大数据时；
   - 在水平方向上进行扩展时；
   - 随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。
   - 高并发解决方案时


## 实现原理
1. 如果删除对象属性，是否从数据库中删除了它？
   - 是的，用户移除属性然后对象会重新保存（re-save()）
2. MongoDB需要大量的内存吗？
    - 需要用到内存的场景：
       - 数据库本身的元数据；
       - 数据库连接使用内存；
       - 查询排序的临时内存；
       - 索引缓存；
       - 查询结果缓存；
       - 主备同步的oplog buffer
    - 当内存不够用时，Mongo可以把内存中的数据放到交换分区。交换分区本质还是磁盘，因此速度肯定没有内存中快
    - 尽量不要开启Swap。开启Swap会导致数据库访问速度变慢，慢的速度不可预知
    - MongoDB可以配置能够使用的最大缓存cacheSizeGB
24. 在MongoDB中配置缓存大小的方法是什么？
    - WiredTiger存储引擎支持cacheSizeDB参数设置缓存大小
    - cacheSizeGB 指的就是Cache size，包括数据和索引。Mongod本身使用内存如连接池堆栈以及sorting buffer等都是额外的，不会被统计到这个数字里面。如果索引在内存，查询冷数据取决于你的IO能力。如果IO latency很低，系统也没有是高负载，那响应时间应该是毫秒级的区别。但是如果查询很频繁，又涉及到很多范围、批量查询，IOPS又跟不上，那就有可能到几百几千毫秒都有可能。

27. 是否可以删除moveChunk目录中的旧文件？
    - 是，完成操作后可以删除这些文件，因为这些文件在正常的分片平衡操作期间作为备份生成。 这是一个手动清理过程，是释放空间所必需的
36. MongoDB以哪种格式表示文档结构？
    - MongoDB使用BSON来表示文档结构
37. 从MongoDB中的数据库中删除文档时会发生什么？ MongoDB是否将文档从磁盘中删除？
    - 删除记录不释放空间：这很容易理解，为避免记录删除后的数据的大规模挪动，原记录空间不删除，只标记“已删除”即可，以后还可以重复利用
    - 可以定期运行db.repairDatabase()来整理记录，但这个过程会比较缓慢
38. 为什么MongoDB数据文件大小总是比较大？
    - 1、空间的预分配：为避免形成过多的硬盘碎片，mongodb每次空间不足时都会申请生成一大块的硬盘空间，而且申请的量从64M、128M、256M那样的指数递增，直到2G为单个文件的较大体积。随着数据量的增加，你可以在其数据目录里看到这些整块生成容量不断递增的文件。
    - 2、字段名所占用的空间：为了保持每个记录内的结构信息用于查询，mongodb需要把每个字段的key-value都以BSON的形式存储，如果value域相对于key域并不大，比如存放数值型的数据，则数据的overhead是较大的。一种减少空间占用的方法是把字段名尽量取短一些，这样占用空间就小了，但这就要求在易读性与空间占用上作为权衡了。我曾建议作者把字段名作个index，每个字段名用一个字节表示，这样就不用担心字段名取多长了。但作者的担忧也不无道理，这种索引方式需要每次查询得到结果后把索引值跟原值作一个替换，再发送到客户端，这个替换也是挺耗费时间的。现在的实现算是拿空间来换取时间吧。
    - 3、删除记录不释放空间：这很容易理解，为避免记录删除后的数据的大规模挪动，原记录空间不删除，
只标记“已删除”即可，以后还可以重复利用。
22. MongoDB数据库是否有用于存储记录的表？
    - 没有，MongoDB使用“集合”来存储数据，而不是表
39. MongoDB中的存储引擎是什么？
    - 存储引擎是数据库的一部分，用于管理数据在磁盘上的存储方式。例如：一个存储引擎可能为读取繁重的工作负载提供更好的性能，另一个可能支持更高的写入操作吞吐量
    - 3.3版本后默认是WiredTiger，3.2版本以前默认是MMAPv1
41. 是否可以在MongoDB中配置MMAPv1的缓存大小？
    - 不可以。不能为MMAPv1配置缓存大小，因为MMAPv1不允许配置缓存大小。
42. 如何在MongoDB中配置WiredTiger的缓存大小？
    - 可以设置cacheSizeDB设置
12. 允许空值null吗
    - 对于对象成员而言，是的。然而用户不能够添加空值(null)到数据库丛集(collection)因为空值不是对象。然而用户能够添加空对象{}
13. 更新操作立刻fsync到磁盘
    - 不会，磁盘写操作默认是延迟执行的。写操作可能在两三秒(默认在60秒内)后到达磁盘。例如，如果一秒内数据库收到一千个对一个对象递增的操作，仅刷新磁盘一次

16. 启用备份故障恢复需要多久
    - 从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费10到30秒时间。这期间在主数据库上的操作将会失败–包括写入和强一致性读取(strong consistent read)操作。然而，你还能在第二数据库上执行最终一致性查询(eventually consistent query)(在slaveOk模式下)
17. MongoDB有几种日志？
    - 系统日志。记录着MongoDB启动和停止的操作，以及服务器在运行过程中发生的任何异常信息。
    - Journal日志。保证数据库服务器在意外断电 、 自然灾害等情况下数据的完整性。简单来说就是预写式日志，写入命令不会立即写入数据库磁盘，但会通过预写式日志记录下来，防止数据库奔溃导致数据丢失。类似于mysql的redo日志
    - oplog日志。类似于MySQL的binlog，记录了所有的写操作，主从同步就是用oplog来做同步的。
    - 慢查询日志



## 索引
1. MongoDB中的索引是什么？
    - 索引是一个B树结构的查询树，用来加快字段的查询。如果没有索引，就必须全表查询才能找到满足条件的记录
14. 默认情况下，MongoDB为每个集合创建了哪个索引？
    - 默认创建了主键_id索引
17. 在MongoDB中为什么使用分析器(Profiler)？
    - 开启profiling功能。db.setProfilingLevel(2);//记录所有命令   db.setProfilingLevel(1, { slowms: 20 }) //记录慢查询
    - 查看 Profile的设置级别。db.getProfilingLevel()
    - 查询 Profiling 记录。与MySQL的慢查询日志不同，Mongo Profile 记录是直接存在系统db里的，记录位置 system.profile ，所以，我们只要查询这个Collection的记录就可以获取到我们的 Profile 记录了。
    - 日常常用查询
       - #返回最近的10条记录。db.system.profile.find().limit(10).sort({ ts : -1 }).pretty()
       - #返回大于5毫秒慢的操作。db.system.profile.find( { millis : { $gt : 5 } } ).pretty()
29. 请解释MongoDB中的覆盖查询是什么？
    - 所有的查询字段是索引的一部分
    - 所有的查询返回字段在同一个索引中
30. 覆盖查询的重要性是什么？
    - 由于所有出现在查询中的字段是索引的一部分， MongoDB 无需在整个数据文档中检索匹配查询条件和返回使用相同索引的查询结果。
    - 因为索引存在于RAM中，从索引中获取数据比通过扫描文档读取数据要快得多。


8. 分析器在MongoDB中的作用是什么
    - MongoDB中包括了一个可以显示数据库中每个操作性能特点的数据库分析器。通过这个分析器你可以找到比预期慢的查询(或写操作);利用这一信息，比如，可以确定是否需要添加索引



## 主备

1. MongoDB的主从复制和副本集的区别？
   - 主从复制。主从复制是可用于备份，故障恢复和读扩展等。基本就是搭建一个主节点和一个或多个从节点，在数据库集群中要明确的知道谁是主服务器，主服务器只有一台。从服务器要知道自己的数据源也就是对应的主服务是谁
   - 复制集。副本集就是有自动故障恢复功能的主从集群，由一个primary节点和一个或多个secondary节点组成。主从集群和副本集最为明显的区别就是副本集没有固定的主节点：整个集群会选举出一个主节点，当其不能工作时，则变更到其它节点。副本集总会有一个活跃节点和一个或多个备份节点
   - 总的来说，主从复制是手动指定主节点和从节点，主节点挂了不能自动切换。副本集模式是自动选举出主节点，主节点挂了后可以自动选举出主节点，具备自动故障转移的功能
29. oplog是什么
   - 当Primary进行写操作的时候，会将这些写操作记录写入Primary的Oplog 中，而后Secondary会将Oplog 复制到本机并应用这些操作，从而实现Replication的功能。同时由于其记录了Primary上的写操作，故还能将其用作数据恢复。可以简单的将其视作Mysql中的binlog
1. MongoDB日记功能是否可用于执行安全热备份？
    - 可以。通过oplog来做主从热备

33. MongoDB中的主副本和次副本集是什么？
    - 在MongoDB中，主节点是可以接受写入的节点。 这些也称为主节点。 MongoDB中的复制是单主机，因此，一次只能有一个节点接受写操作。 辅助节点称为从节点。 这些是从主数据库复制的只读节点
17. 什么是master或primary
    - 它是当前备份集群(replica set)中负责处理所有写入操作的主要节点/成员。在一个备份集群中，当失效备援(failover)事件发生时，一个另外的成员会变成primary
18. 什么是secondary或slave
    - Seconday从当前的primary上复制相应的操作。它是通过跟踪复制oplog(local.oplog.rs)做到的。

7. journal回放在条目(entry)不完整时(比如恰巧有一个中途故障了)会遇到问题吗
    - 每个journal (group)的写操作都是一致的，除非它是完整的否则在恢复过程中它不会回放


## 集群
1. Mongo集群的原理
   - 集群的三个重要组件Mongos，Config Server，Shard
   - **Mongos：路由节点**。Mongos给客户端提供一个访问节点，使客户端操作集群就像是在操作单个实例。它本身是一个无状态节点，只从Config Server拉取分块的配置信息
   -** Config Server：配置信息节点**。保存了所有分块所在节点以及取值范围的信息。它本身是一个至少3节点的集群，使用两阶段提交协议来保证配置的一致性以及写入的效率
   - **Shard：分片，数据节点**。保存实际的数据，每个shard其实就是一个Mongod实例，或者说是一个复制集（replica set）。
   - ![](https://raw.githubusercontent.com/roperluo32/images/master/image20191218073116.png)

2. 什么是分块
   - **逻辑分片**。分块的概念类似于ElasticSearch的分片，以及Redis的16384个槽，它是一个中间层概念，暂且叫它逻辑分片。
   - **使用过程**。分为映射和分配两个阶段。
       - 映射。数据使用会先通过某种方式（hash计算或者范围分配）映射到这个中间层。
           - Elastic是通过公式：hash(docID)%分片数 
           - Redis通过公式：crc16(key)%16384，
           - Mongo则是通过自动地对分片键做范围分配到某个逻辑分片
       - 分配。然后再通过某种方式（比如redis的手动指定或者elasitc的自动分配片）去把这个中间层复杂均衡到实际的机器节点上。
           - Elastic是通过master节点自动分配分片到节点
           - Redis是手动指定槽到节点
           - Mongo也是自动分配逻辑分片（块）到节点

2. 如何选择分片键
   - **自增ID**。优点：方便范围读取。缺点：写数据集中在某个分片，有写热点问题
   - **随机hash**。优点：数据均匀分散到多个分片。负载均衡。缺点：读取数据需要遍历所有分片
   - **粗粒度键**。优点：既能利用集群分片优势，也能有局部性优势。缺点：键是分块的依据，如果一个键下面数据太多，会导致分块太大。
   - **组合键（粗粒度键+自增ID）**。既利用了粗粒度建的优势，同时使用自增ID避免了粗粒度键的无法分块的缺点。
3. 如果分片已关闭或缓慢但是正在进行查询，该怎么办？  
   - 如果分片已关闭，但正在进行查询，那么除非设置了部分查询选项，否则将返回包含错误的查询。 但如果一个碎片很慢，查询会等待它们直到有所反应
4. 分片(sharding)和复制(replication)是怎样工作的  
   - 每一个分片(shard)是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片(shard)使用集群
5. 数据在什么时候才会扩展到多个分片(shard)里
   - MongoDB 分片是基于区域(range)的。所以一个集合(collection)中的所有的对象都被存放到一个块(chunk)中。只有当存在多余一个块的时候，才会有多个分片获取数据的选项。现在，每个默认块的大小是 64Mb，所以你需要至少 64 Mb 空间才可以实施一个迁移
6. 当我试图更新一个正在被迁移的块(chunk)上的文档时会发生什么
   - 更新操作会立即发生在旧的分片(shard)上，然后更改才会在所有权转移(ownership transfers)前复制到新的分片上
7. 如果块移动操作(moveChunk)失败了，我需要手动清除部分转移的文档吗
   - 不需要，移动操作是一致(consistent)并且是确定性的(deterministic);一次失败后，移动操作会不断重试;当完成后，数据只会出现在新的分片里(shard)
8. 默认的块大小？
   - 默认的chunk size 是64MB


## 事务&锁
1. MongoDB支持事务吗
   - MongoDB不支持多个文档的事务。然而，MongoDB提供在单个文档中的原子操作。通常情况下文档级别的原子操作足够解决在关系数据库中要求ACID事务的大多数问题。
43. MongoDB如何提供并发性？
    - 在3.0版本中MongoDB的锁机制就有了比较大的改进，跟常见的数据库锁机制比较相似了。3.0还是使用读写锁机制，只是支持了多粒度的锁，支持全局、数据库、集合这几个粒度的锁（锁的粒度待到下面章节来详细了解）。MongoDB支持插件式的存储引擎，这样允许存储引擎自己来实现比集合粒度更细的并发控制(例如在3.0版本中引入了WiredTiger引擎，这个引擎支持文档粒度的锁)。
    - 在3.0中除了"共享锁S"(我个人理解就是读锁)和"互斥锁X"(也就是写锁)以外还加入了"意向共享锁IS"和"意向互斥锁IX"，这两种类型的锁预示我们后面需要更细粒度的锁来读写资源。当我们用某一粒度的锁以后所有比这个粒度大的地方都用"意向锁"来锁定
14. 如何执行事务/加锁
     - MongoDB没有使用传统的锁或者复杂的带回滚的事务，因为它设计的宗旨是轻量，快速以及可预计的高性能。可以把它类比成MySQL MylSAM的自动提交模式。通过精简对事务的支持，性能得到了提升，特别是在一个可能会穿过多个服务器的系统里
15. MMAPv1引擎和wiredTiger引擎的锁级别？
     - MMAPv1引擎是针对collection进行加锁
     - wiredTiger引擎针对文档进行加锁，粒度更小，并发性更高

## 用法
- [MongoDB知识整理](https://www.cnblogs.com/xing901022/p/3978243.html)
- [Mongodb 中文文档](https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/introduction.html#%E4%BB%8B%E7%BB%8D)
-  各个数据库的对比

empty | 使用场景 | 类型 | 存储模型 | 主从高可用 | 集群分片 | 并发事务和锁
---|---|---|---|---|---|---
MySQL | 需要事务，数据之间关系强连接|
Redis| 数据缓存，消息队列
ElasticSearch|数据分析&查询需求
MongoDB|数据聚合属性强，不同数据之间关系弱，数据字段变化多，事务性弱|




## 链接
- [MongoDB面试题及答案](https://www.kaops.com/iv/430)
- [28个MongoDB经典面试题](https://searchdatabase.techtarget.com.cn/7-22241/)
- [MongoDB知识整理](https://www.cnblogs.com/xing901022/p/3978243.html)
- [MongoDB技术文章合辑1：基础知识](https://zhuanlan.zhihu.com/p/75312460)
- [Mongodb 中文文档](https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/introduction.html#%E4%BB%8B%E7%BB%8D)
