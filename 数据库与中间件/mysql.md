## 索引原理
1. 有哪些索引
    - 从物理角度：聚簇索引，非聚簇索引
    - 从数据结构：hash索引，b+树索引，全文索引，空间索引
    - 从应用角度：主键索引，单列索引，多列索引，覆盖索引
2. 聚集索引和非聚集索引里面的存储的结构以及插入数据之后索引的维护过程
![](http://images-1251273400.cosgz.myqcloud.com/20201008094533.png)
3. MySQL的聚簇索引和非聚簇索引有什么区别
    - 聚簇索引一般是主键的索引，叶子节点包含的是整行数据
    - 非聚簇索引一般是非主键索引，叶子节点包含的是索引列值和主键值
4. 针对一个场景设计索引，具体场景忘记了，反正考察的是联合索引与列选择性的知识
5. 假如要查 A in () AND B in (), 怎么建索引
    - 建一个idx_A_B的索引
6. 查 A in () AND B in () 时, MySQL 是怎么利用索引的
    - 会在索引上做range或者全索引查找
    - 最好建立的idx_A_B索引能够是覆盖索引，这样可以不用再做回表查询
7. 假如查询 A in (), MySQL 是针对 N 个值分别查一次索引, 还是有更好的操作
    - 不会分别查一次，而是先对in列表做排序，然后再做range查询
8. mysql存储引擎中索引的实现机制，索引树是如何维护的？
    - 每种存储引擎的索引实现机制都是不一样的。以innodb为例，它的索引是以B+树实现的，物理上分为聚簇索引和非聚簇索引，聚簇索引一般是主键的索引，叶子节点保存着整行数据。非聚簇索引是其它列的索引，叶子节点保存着索引列值和主键值。
9. 数据库自增主键可能的问题
   - 高并发情况时表锁的问题
   - 单点问题，无法分表
   - 解决办法：分库分表，使用全局ID生成器，比如twitter开源的snowflake，不能用UUID，因为它太长（36字节），是完全随机的，插入索引树会导致大量的数据移动和分页。
10. mysql索引为什么使用B+树
    - B+树是对磁盘友好的。它的高度只有2~4次，叶子节点存放所有数据。
    - B+树内部节点不存放键的具体信息，因此索引树整体比较小，可以放进内存，检索效率高
    - 查询效率比较稳定，所有查询都是从根节点到叶节点。
    - 叶子节点时排序存储的，并且用指针互相连接，方便顺序查找和排序
12. 索引失效场景，SQL什么情况下不会使用索引（不包含，不等于，函数）
     - 索引列在表达式，函数中
     - 范围表达式，大于，小于，不等于等
     - 通配符开头的模糊搜索
     - 还有一种情况，当优化器发现使用二级索引的效率不如全表扫描时
13. 一般在什么字段上建索引（过滤数据最多的字段）
     - 在where中出现次数比较多的列；选择性比较高的列
15. 主键和候选键有什么区别
     - 主键是候选键的子集

17. 索引的使用注意事项
     - ![](https://raw.githubusercontent.com/roperluo32/images/master/image20191123212304.png)
18. 联合索引
    - 多个列组成的二级索引
19. 从底层解释最左匹配原则
    - 多列索引是首先按第一列排序，然后按第二列这样依次排序下去。因此查询时，必须先按照第一列依次查找，接着第二列等等。而不能直接按照第二列来查找，因为第二列不是排序好的。
20. Mysql对联合索引有优化么？会自动调整顺序么？哪个版本开始优化？
21. 数据库自增主键可能的问题
    - 高并发情况下有表锁
    - 限制在单表，无法分表分库
22. mysql索引为什么使用B+树
    - B+树对磁盘查找是优化的，它的内部节点只存放键，因此一次可以尽可能多地把索引读进内存。
    - B+树的叶子节点时排序好的，并且页之间用链表连接起来，方便范围和排序查找
23. B+索引数据结构，和B树的区别
    - B+树的内部节点只存储键，不存储数据，B树叶存储数据
    - B+树的数据节点都集中在叶子节点，B树分散在整棵树中
    - ![B树](https://raw.githubusercontent.com/roperluo32/images/master/image20191123215119.png)
    - ![B+树](https://raw.githubusercontent.com/roperluo32/images/master/image20191123215139.png)
24. 索引有B+索引和hash索引，各自的区别
    - hash索引只适合做单值查找，无法做范围和排序
    - b+索引支持范围，排序查找，随机查找也有很好的性能
25. 主键和唯一索引的区别
    - 主键一定是唯一索引，但唯一索引不一定是主键
    - 主键不能为空，唯一索引可以为空
    - 只能有一个主键索引，但可以有多个唯一索引
26. 什么是覆盖索引
    - 能够使查询只使用索引，而不需要回表查询数据的索引，就是覆盖索引
27. 为什么选用自增量作为主键索引
    - 自增量作为主键的好处是，数据插入时能有很好的性能，减少了数据移动和分页的可能性
28. mysql索引设计一般考虑什么
    - 优先考虑优化查询语句，利用好现有的索引，实在无法优化时再新建索引
    - 索引的三星原则：1，与查询相关的索引行是相邻的，也就是where后面的等值谓词，可以匹配索引列顺序 2，索引行的顺序与查询语句需求一致，也就是order by 中的排序和索引顺序是否一致 3，索引行包含查询语句中所有的列
29. abc索引，搜索b，会使用索引吗
    - 可能会使用索引，但也只是可能利用索引做扫描查询
29. 索引什么时候会失效变成全表扫描
    - 当优化器认为在索引上查找后的反表查询耗时大于全表扫描时，就会采取全表扫描
30. 解释mysql索引、b树，为啥不用平衡二叉树、红黑树
    - 红黑树是一种退化的平衡二叉树，平衡二叉树的旋转操作代价太大，红黑树利用红黑色的策略降低了维护平衡代价
    - 红黑树和平衡二叉树对随机查找友好，但是磁盘对大批量的随机查找是不友好的。同时红黑树不支持排序和范围查找
    - B+树是对磁盘优化的数据结构。它支持范围和排序。
31. 查询中哪些情况不会使用索引？
    - 见问题14的答案
32. 从innodb的索引结构分析，为什么索引的 key 长度不能太长
    - 索引key太长的话，会导致索引太大，同时查找的效率比较低
33. 使用int 做primary key和使用string 有什么优劣？
    - 看情况。。
34. 主键 超键 候选键 外键
    - ![](https://raw.githubusercontent.com/roperluo32/images/master/image20191123220726.png)
35. LSM与B+树的对比
    - **LSM(Log-Structured Merge Tree)**,结构化合并树，核心思想就是不将数据立即从内存中写入到磁盘，而是先保存在内存中，积累了一定量后再刷到磁盘中

    - **LSM VS B-Tree**.LSM在B-Tree的基础上为了获取更好的写性能而牺牲了部分的读性能，同时利用其它的实现来弥补读性能，比如boom-filter.
    - **写**. B树的写入，是首先找到对应的块位置，然后将新数据插入。随着写入越来越多，为了维护B树结构，节点得分裂。这样插入数据的随机写概率就会增大，性能会减弱。LSM 则是在内存中形成小的排好序的树，然后flush到磁盘的时候不断的做merge.因为写入都是内存写，不写磁盘，所以写会很高效。另外全是顺序写，没有随机写
    - **读**. B树从根节点开始二分查询直到叶子节点，每次读取一个节点，如果对应的页面不在内存中，则读取磁盘，缓存数据。LSM树整个结构不是有序的，所以不知道数据在什么地方，需要从每个小的有序结构中做二分查询，找到了就返回，找不到就继续找下一个有序结构。所以说LSM牺牲了读性能。但是LSM之所以能够作为大规模数据存储系统在于读性能可以通过其他方式来提高，比如读取性能更多的依赖于内存/缓存命中率而不是磁盘读取。
## 性能优化
1. MySQL的几种优化
   - https://juejin.im/post/59d83f1651882545eb54fc7e#heading-15
   - 查询优化
   - 索引优化
   - 数据库结构设计（表的垂直和水平拆分）
   - 架构优化（主备&读写分离）
2. 如何优化数据库性能（索引、分库分表、批量操作、分页算法、升级硬盘SSD、业务优化、主从部署）
   - 查询优化
     - 通过慢查询分析哪些sql查询需要优化
     - 通过explain和profiling分析sql语句要怎么优化
     - 尽量不要用select * (会导致回表和全表查询，很难使用覆盖索引)
     - 联合查询时，用小表驱动大表查询
     - 用连接代替子查询，因为join不会创建临时表
     - 适当增加字段冗余，减少表join
     - 充分利用索引，特别是排序和分组。减少filesort和temprory
   - 索引优化
     - 为频繁查询的字段建立索引
     - 为选择度高的字段建立索引
     - 索引三星原则的最高原则：可以覆盖查询语句中的所有字段
     - 不要对记录太少，经常增删改的表建索引
4. 数据库优化步骤（explain，慢查询，show profile）
     - 先用慢查询定位需要优化的查询
     - 再用explain和profiling去分析怎么优化sql
5. 数据库的优化（从sql语句优化和索引两个部分回答）
    - 查询优化
      - 不要用select *
      - 联合查询时，用小表驱动大表查询（IN和EXIST）
      - 排序和group都尽量去使用索引，减少filesort和temprory
      - 适当增加字段冗余，减少join
    - 索引优化
      - 索引字段不能太长
      - 复合三星原则：等值&排序字段顺序与索引字段顺序一致，索引可以覆盖查询的所有字段
      - 索引适合建在记录多，读多写少的表上
6. mysql查询优化，慢查询怎么去定位？
      - MySQL 提供 mysqldumpslow 工具对日志进行分析。我们可以使用 mysqldumpslow --help 查看命令相关用法
      - 常用参数如下：
    
    `-s：排序方式，后边接着如下参数
        c：访问次数
        l：锁定时间
        r：返回记录
        t：查询时间
    al：平均锁定时间
    ar：平均返回记录书
    at：平均查询时间
    -t：返回前面多少条的数据
    -g：翻遍搭配一个正则表达式，大小写不敏感`

7. 如何预估一个mysql语句的性能？
    - 使用explain分析查询的性能
    - 关注关键的两个字段type和extra
    - type的取值：system，const，eq_ref, ref，range, index，all.其中为index和all意味着需要优化。index代表遍历索引，all意味着遍历全表数据
    - extra的取值：filesort, temporary, using where, using index.其中为filesort和temporary意味着需要优化，意味着需要利用临时空间进行额外排序。
    - 另外还可以关注rows和filted。rows代表找到所需记录需要读取的行数，越小越好。filted代表返回结果的行数占从数据库中读出来行数的比例，越大越好。

## 高并发 & 分库分表
1. 列举出你能想到的数据库分库分表策略；
    - 连续分片。缺点是如果按时间划分，会导致节点负荷不均，并且无法避免写入负载高的问题
    - ID取模分片。缺点：扩容需要迁移数据
    - 一致性HASH分片。扩容后无须迁移数据
    - snowflake分片算法。使用时间戳来区分扩容前和扩容后的数据，分别使用不同的寻址算法。
2. 分库分表后，如何解决全表查询的问题。
    - 对于多表查询
       - 尽量按业务主查询ID去做分片分表，这样能是主ID对应的数据都在同一个分片
       - 变动少的表可以每个分片都保存一份，减少跨分片join
       - 保持适当的字段冗余，减少join
    - 对于单表的全表查询
       - 尽量指定主查询ID，这样能缩小分片的读取量
       - 对于没有指定主查询ID的情况，只能做全分片扫描读取
2. 数据库万级变成亿级，怎么处理  
    - 分库分表，主从复制，读写分离。
3. Mysql怎么分表，以及分表后如果想按条件分页查询怎么办
    - 最差的办法就是每个分片返回offset+limit，然后在代理层聚合
    - 业务折中：只允许连续翻页，不允许跳页；或者允许非精准跳页，假设数据在所有分片上是均匀分布，这样只用返回每个分片的top limit/N就行了
    - 另外优化查询速度的办法：利用延迟查询方法。先充分利用覆盖索引，查询出满足条件的主键，做完聚合后，再去根据主键捞字段
4. 分表之后想让一个id多个表是自增的，效率实现
    - 使用全局ID
    - 一般不用UUID，缺点：字段太长（36字节），并且是完全随机
    - 一般使用Redis或者snowflake算法来实现一个全局ID生成器

7. MySQL与MongoDB的区别，海量数据的存储
8. mysql数据量多大的时候需要分表
    - 没有固定的答案，一般根据表的用途和业务来要求来评估此数据量
    - 单表只有insert和单条查询的，这种单表千万级别没问题
    - 如果表中有update，in查询，分页等操作，就会严重影响性能，建议数据到达300w时就要考虑分表了

12. 全局ID生成方法
    - 设置自增步长。缺点是扩容时需要迁移数据
    - 全局ID映射表，利用redis记录每张表的ID增长。缺点是redis需要定时持久化
    - UUID。缺点是长度太长（36字节），同时它是完全随机，对索引不友好
    - COMB。UUID+时间，达到有序的目的，提高索引性能，但更长了
    - snowflake。雪花算法，Twitter开源的全局ID算法，生成ID长度64bit，（时间id+节点id+序列号）
13. 有哪些分片策略
    - 连续分片。缺点是如果按时间划分，会导致节点负荷不均，并且无法避免写入负载高的问题
    - ID取模分片。缺点：扩容需要迁移数据
    - 一致性HASH分片。扩容后无须迁移数据
    - snowflake分片算法。使用时间戳来区分扩容前和扩容后的数据，分别使用不同的寻址算法。
14. 分库分表引入的问题
    - 分布式事务。解决方法见下面问题
    - 跨节点join
      - 尽量把属于同一ID的数据划分到同一节点。通常是基于业务主逻辑ID来分shard节点。比如电商的用户ID，游戏的游戏用户ID等
      - 对于稳定不变的数据表，可以在所有节点上都存一份
      - 适当增加表字段冗余，减少join
    - 跨节点聚合。只能在应用层或者代理层去做聚合
    - 节点扩容。需要做数据迁移
15. 常见的分库分表中间件
    - sharding
    - TDDL Smart Client的方式（淘宝）
    - Atlas(Qihoo 360)
    - alibaba.cobar(是阿里巴巴（B2B）部门开发)
    - MyCAT（基于阿里开源的Cobar产品而研发）
    - Oceanus(58同城数据库中间件)
    - OneProxy(支付宝首席架构师楼方鑫开发)
    - vitess（谷歌开发的数据库中间件）
    - [分库分表](https://zhuanlan.zhihu.com/p/54921615)

## 锁
1. 数据库锁表的相关处理
2. 高并发下如何做到安全的修改同一行数据，INNODB的行级锁有哪2种，解释其含义
    - 通过对这行加写锁（一般是悲观锁），来实现安全修改同一行数据
    - 行级锁分为共享锁和排它锁。共享锁就是读锁，排他锁就是写锁
3. 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁
    - 死锁例子：1. 两个事务以不同顺序对同一行数据进行加锁 2. 两个事务以不同顺序对同一段数据加Gap锁
    - 数据库实现了死锁检测机制和死锁超时机制
    - 如果检测到死锁，会回滚排他锁比较少的事务

4. 数据库隐式加锁
    - InnoDB自动加意向锁。
    - 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；
    - 对于普通SELECT语句，InnoDB不会加任何锁
7. 数据库的锁（行锁，表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁，以及加锁的select sql方式）
    - 行锁，表锁，页级锁，是按照锁的粒度划分的。粒度越小，并发成都越高，但锁维护成本也越高，出现死锁的几率也高
    - 意向锁。当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁
    - 读写锁也称之为共享锁和排它锁。是行锁的两种具体类型。主要表现为互斥的行为不同
    - 乐观锁和悲观锁。是写锁的两种实现。乐观锁的实现一般有CAS和额外版本字段两种方式，适用于读多邪少的情况。悲观锁一般是直接加锁，适用于写多读少的情况。
11. 有哪些锁（乐观锁悲观锁），select时怎么加排它锁
    - select加排他锁。select * from xxx FOR UPDATE
    - select加共享锁。select * from xxx LOCK IN SHARE MODE

13. 如何避免死锁
    - 将大事务分割为小事务
    - 降低事务等级。RR级别的Gap锁经常会导致死锁
    - 避免同一时间频繁修改同一段数据
    - 合理利用索引，减少锁表
    - 设置锁超时时间：innodb_lock_wait_timeout
    - https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html
    - ![](https://raw.githubusercontent.com/roperluo32/images/master/image20191125200337.png)
11. 高并发访问 MYSQL 时，如何保持数据一致性
    - 一般通过加锁来实现数据的一致性。根据锁的粒度有表锁和行锁。根据类型还有共享锁(读锁)和排它锁(写锁)。根据实现方式又有乐观锁和悲观锁
    - 事务的ACID特性。原子性，一致性，隔离性，持久性
    - 隔离性的四种级别。RU,RC,RR,SE
11. Mysql要加上nextkey锁，语句该怎么写
    - select * from xxx FOR UPDATE
    - select * from xxx LOCK IN SHARE MODE
    - [Innodb锁机制：Next-Key Lock 浅谈](https://www.cnblogs.com/zhoujinyi/p/3435982.html)
    - [MySQL innodb中各种SQL语句加锁分析](http://www.fordba.com/locks-set-by-different-sql-statements-in-innodb.html)
----
#### 资料：

[MYSQL索引加锁分析](https://www.jianshu.com/p/13f5777966dd) 

## 事务 & 隔离级别
1. 数据库隔离级别是什么？有什么作用？
   - 有四种隔离级别：Read UnCommited，Read Commited，Reapted Read， Serialized
   - 四种隔离级别分别有不同的问题，用来保证不同级别的并发安全程度。并发安全程度越高，加锁成本就越高，并发速度就越低。因此定义隔离级别可以方便地去根据业务需求做取舍
3. 隔离级别，依次解决的问题（脏读、不可重复读、幻读）
    - RC解决了脏读问题，不会读到其它事务没有提交的修改
    - RR解决了RC的不可重复读。RC虽然解决脏读，但是重复读取同一行数据还是可能重复。RR可以保证重复读取同一行值不会变。但是RR存在幻读问题，即重复读取一个区间的数据，会读到不同的值。mysql通过"行排它锁+MVCC"解决幻读问题
6. 什么是一致性
    - 数据库总是从一个一致性的状态转换到另一个一致的状态。假如一个事务执行到一半，数据库挂掉了。那么数据库重启后，不会处于这个事务的中间状态，因为事务没有提交，它的修改就不会提交
7. 什么是隔离性
    - 一个事务所做的修改在提交之前是不会被其它事务见到的
10. 数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别
    - RU，脏读问题
    - RC，不可重复读问题
    - RR，幻读问题
    - SERIALIZE，退化为了基于锁的并发，性能低
    - mysql默认是在RR级别



## sql用法
1. select * from table t where size > 10 group by size order by size的sql语句执行顺序？
2. 如何从一张表中查出name字段不包含“XYZ”的所有行？
    - select * from xxx where name not LIKE '%XYZ%'
3. 一张表里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把mysql重启，再insert一条记录，这条记录的ID是18还是15
    - innodb重启后是15，因为innodb的计数器是保存在内存中
    - MYSIAM重启后是18，因为计数器是保持在磁盘中的
4. 如何区分FLOAT和DOUBLE？
    - 参考 [MySQL如何选择float, double, decimal](http://blog.leanote.com/post/weibo-007/mysql_float_double_decimal)
    - FLOAT使用32位存储，可以精确到6个小数点
    - DOUBLE使用64位存储，可以精确到13个小数点
    - demical，使用字符串存储小数，可以做到精确。
5. 区分CHAR_LENGTH和LENGTH？
    - CHAR_LENGTH返回的是字符的数量，一个中文字符是1
    - LENGTH返回的是字节数量，一个中文字符是3
6. 如何控制HEAP表的最大尺寸
    - 修改max_heap_table_size参数
7. 如果一个表有一列定义为TIMESTAMP，将发生什么
    - 每当行被更改时，时间戳字段将获取当前时间戳。
8. LIKE声明中的％和_是什么意思
    - %表示匹配任意字符任意次数(包括0次)
    - _表示匹配任意字符一次，不能多不能少
9. 如何在Unix和mysql时间戳之间进行转换
    - 时间戳转日期格式 -- select FROM_UNIXTIME(1156219870);
    - 日期格式转时间戳 --    Select UNIX_TIMESTAMP('2006-11-04 12:23:00');
10. LIKE和REGEXP操作有什么区别
    - LIKE：默认是匹配整个行，支持'%'和‘-’两个模式
    - REGEXP：默认是只要行中有指定模式就匹配，支持常规的正则表达式，比如|，范围[]，次数{}，^$等等
    - 资料：[MySQL的正则表达式的LIKE和REGEXP区别](https://www.cnblogs.com/Guhongying/p/10542792.html)
    - [MySQL学习笔记：like和regexp的区别](https://www.cnblogs.com/hider/p/9121704.html)
12. 数据库表包含三列：广告编号ad_id，广告开始投放时间ad_start，广告投放结束时间ad_end。用一行SQL语句查询给定时间段内存在的广告
    - select ad_id from table where ad_start > time_s and ad_end < time_e;
13. drop,delete与truncate的区别
    - drop > truncate > delete
    - drop是将整个表删除，渣渣都不剩，包括表结构和其它触发器等
    - truncate只删所有表数据，不会激活触发器，删除后再插入数据后，自增长id从1开始，不能回滚，速度比较快
    - delete可以指定where条件删除指定行，会激活删除相关的触发器，可以回滚
    - drop和truncate慎用，大部分时候用delete
    - [drop,delete与truncate的区别](https://www.jianshu.com/p/9d6c6e5d676f)
14. 连接的种类
    - 外连接：左连接(left join) & 右连接(right join)
    - 内连接：inner join
    - 全连接：cross join(select * from table1 cross join table2),产生的结果行数是table1行数乘以table2行数
    - [连接的种类
](http://www.manongjc.com/article/68525.html)
15. 存储过程与触发器的区别
    - 触发器是一个特殊的存储过程，当一个预定义的事件（SELECT,UPDATE,DELETE等）发生时，由MYSQL自动调用
    - 存储过程是为了完成特定功能经过编译的sql语句集
    - [存储过程和触发器以及自定义函数的区别](https://blog.csdn.net/wuhan_yking/article/details/53178320)
16. CHAR和VARCHAR的区别？
    - CHAR: 固定长度，最大255个字节，存储和检索效率比较高。空余的空间会用空格填充，检索CHAR值时需删除尾随空格。
    - VARCHAR：可变长度，最大65535个字节，只会使用实际字符串长度+1的空间。
    - [mysql中char与varchar的区别分析](https://www.jb51.net/article/23575.htm)
17. int和字符串后面的数字含义
    - int：int后面数字只是代表显示出数字的长度，左边补0.实际存储的长度只跟int有关
    - 字符串：CHAR后面的数字代表实际存储的长度。VARCHAR后面的数字代表最大的存储长度，实际存储长度就是实际存储的字符串长度+1
    - [数据库优化第一步：数据类型](https://zhuanlan.zhihu.com/p/67253442)

18. IP地址如何在数据库中存储?
    - 字符串存储。varchar(15)
    - 整型int存储。使用函数将ip转成整数：select inet_aton("192.168.0.1")

## 主备同步
1. MySQL主备同步的基本原理
   - 主mysql将更改日志写入binlog。主mysql上的binlog dump线程将监听binlog，并将其更改同步给从mysql
   - 从mysql上的io线程监听主mysql的dump线程发过来的通知，将其写入relay log。从mysql上的sql线程读取relay log，并将其应用到数据库中
   - binlog有三种
       - statement：记录对数据库操作的sql语句。体积比较小，会丢失now(),time()这些数据
       - row：将每一条数据的变化写入到binlog中。体积比较大，不会丢失数据
       - mixed：statement与row的混合
2. 数据库主从复制什么时候会出现数据不一致，如何解决
    - 主的配置高于从，写入速率比从快
    - 网络延迟
    - 自增键和自增步数不一致
    - 同步参数有问题
    - mysql自身bug或者版本不一致，导致有些主上面的高级特性无法在从上面执行
    - [MySQL主从不一致情形与解决方法](https://blog.csdn.net/hardworking0323/article/details/81046408)
6. MySQL的数据如何恢复到任意时间点？
   - 恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础上回放增加的 binlog 直至指定的时间点。
7. 怎么订阅分库分表的Binlog 
   - 使用阿里中间件canal订阅
   - [研发应该懂的binlog知识(上)](https://www.cnblogs.com/rjzheng/p/9721765.html)
   - [面试官:"谈谈分库分表吧？"](https://zhuanlan.zhihu.com/p/54921615)


## 引擎
1. MySQL 的存储引擎用的是什么?（InnoDB）为什么选 InnoDB
    - innodb支持事务；支持行级锁，在高并发读写情况下有比较好的性能。适合读写比较多，对可靠性和事务有要求的场景
    
2. MySQL InnoDB存储的文件结构
   - 从大到小分别为：表空间、段、区、页
   ![](https://raw.githubusercontent.com/roperluo32/images/master/image20191201093319.png)
   - [InnoDB逻辑存储结构](https://www.jianshu.com/p/1573c4dcecd6)
3. mysql的三大引擎是啥
   - Innodb，Myisam，Memory
6. MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景
   - Innodb：支持事务，支持行级锁，高并发读写有较好的性能。适合读写比较多，对可靠性和事务有要求的场景
   - Myisam：不支持事务，支持表锁，记录了表行数，select count(*)时由较好的性能。适合读多写少，不需要支持事务的场景
   - [MySQL存储引擎MyISAM与InnoDB区别总结整理](https://blog.csdn.net/xlgen157387/article/details/68978320)



## 范式
1. 数据库的范式
   - 第一范式：所有列都不可再分割
   - 第二范式：所有非主属性都完全依赖于主属性（但也可能依赖于某个非主属性），所谓完全依赖是指不能存在仅依赖主关键字一部分的属性
   - 第三范式：属性不依赖于其它非主属性
   - 举例：假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字"学号"。该表符合第二范式，所有属性都依赖于主属性。但是不符合第三范式，学院地点于所在学院有依赖关系
   - [数据库范式（1NF 2NF 3NF BCNF）详解](https://blog.csdn.net/ljp812184246/article/details/50706596)
3. mysql范式和反范式的区别以及彼此的优缺点
   - 范式：优点是重复数据少，数据更新方便。缺点是冗余数据少，查询需要join连接很多表，可能导致索引策略失效
   - 反范式：优点是保持一定的字段冗余，可以减少查询时的连表join操作，并且可以更好地设计索引去优化查询。缺点是更新数据麻烦，冗余数据需要额外更新，可能存在数据不一致。


## 其它问题
1. 有用过 MySQL 的什么高级特性吗
   - 分区表
   - 外键约束
   - 存储过程&触发器
2. mysql的技术特点是什么？
   - 多线程，支持多处理器
   - 支持多种数据类型（int，bigint，float，double，demical，char，varchar，text，blob，timestamp，datetime）
   - 支持多平台，windows，linux，mac等
   - 支持多语言，c，c++，python，java，php等
3. 与Oracle相比，mysql有什么优势？
   - Mysql优势：开源，免费，活跃社区支持，对硬件要求低
   - Mysql缺点：不支持热备，
   - Oracle优势：处理速度快，安全级别高，故障处理快
   - Oracle缺点：价格高，机器配置要求高，管理运维操作复杂
   - [oracle 数据库的优势在哪](https://www.v2ex.com/t/406027)
   - [mysql与oracle的优缺点](https://blog.csdn.net/cxws110/article/details/73164275)
4. 如何获取当前的mysql版本
   - select version();

7. 视图的作用，视图可以更改么？
   - 视图即是虚拟表，也称为派生表，因为它们的内容都派生自其它表的查询结果。虽然视图看起来感觉和基本表一样，但是它们不是基本表。基本表的内容是持久的，而视图的内容是在使用过程中动态产生的
   - 作用：1，简化用户查询操作 2，安全需求。对机密数据提供保护 3，兼容旧表
   - 问题：需要考虑视图的性能问题。视图有两种实现算法：1，MERGE和TEMPTABLE
   - MERGE算法类似于宏展开，将视图sql语句与查询sql合并为一个sql。如果sql语句中有group by，having，聚集函数等就不能用MERGE算法
   - TEMPTABLE是将视图的结果保存为一张临时表来提供查询。需要确保视图的记录不会太多
   - [mysql 视图的作用](https://blog.csdn.net/wangsifu2009/article/details/6719847)
   - [MySQL中的视图及性能问题](https://blog.csdn.net/adparking/article/details/6388873)
 

[mysql事务、redo日志、undo日志、checkpoint详解](https://zhuanlan.zhihu.com/p/34650908)
