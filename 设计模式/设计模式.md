- 总览图
![](http://images-1251273400.cosgz.myqcloud.com/20201017111416.png)

- 单例模式及其应用
    - 这个网上随便找一篇介绍单例模式的文章都有详细地介绍。我就从基本的单例模式到线程安全的单例模式, 用智能指针管理的单例等大概说了说。
    - 关于应用, 我就举了 《Effective C++》中的一个例子。定义在两个文件下的全局变量A, B,然后A 需要用 B 来初始化, 但是由于不知道 B 是否在 A 初始化时, 已经初始化了。因此我们可以用单例来封装一下, 从而保证了其 B 在 A 之前初始化

- 介绍下工厂模式和装饰器模式

## 一，创建型模式

- 简单工厂模式（Simple Factory）
	- 使用简单的方法封装创建对象的过程
- 工厂方法模式（Factory Method）
	- 抽象出创建对象的方法，以避免对象的改变导致创建方法的改变
- 抽象工厂模式（Abstract Factory）
	- 工厂方法只对一个方法抽象，而抽象工厂是对一个产品族做抽象。缺点是产品族中要增加产品比较困难，所有的具体实现类都要改变

- 适配器模式
	- 场景：适配器模式用于转换一种接口适配另一种接口

- Builder生成器模式
	- 场景：对象属性繁多，一般都具有5个或者5个以上的属性，特别是大多数参数都是可选的时候

- 原型模式
	- 通过给出一个原型对象来指明所有创建的对象的类型，然后用这个原型对象提供的复制办法创建出更多同类型的对象
	- 原型模式要求对象实现一个可以克隆自身的接口(类型)。这样一来，通过原型实例创建新的对象，就不需要关心这个实例本身的类型，只需要实现克隆自身的方法，也而无需再去通过new来创建


## 结构型模式
- 外观模式（Facade）
	- 场景：已有多个子系统/ 多个复杂的类，通过创建一个统一的外观类，用来包装这些子系统/复杂类。客户端可通过调用外观类的方法来调用内部子系统中所有方法
	https://www.jianshu.com/p/1b027d9fc005

- 适配器模式（Adapter）
	场景： 把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作

	代理模式（Proxy）
	给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用
	
- 组合模式（Composite）
	- 组合多个对象形成树形结构以表示具有 "整体—部分" 关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为 "整体—部分"(Part-Whole) 模式，它是一种对象结构型模式
	- 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们
	- 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数 2，树形菜单，文件、文件夹的管理
	
- 享元模式（Flyweight）
	- 运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用
	
- 装饰模式（Decorator）
	- 以组合的方式动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活
	
- 桥模式（Bridge）
	- 把抽象化与实现化解耦，使得二者可以独立变化
	- 把经常变化的部分抽象成接口形式，以子对象组合的方式存在到主对象中

	
## 行为型模式
- 中介者模式（Mediator）
	- 一个模块或者系统，可能由多个对象构成，这些对象之间可能存在互相调用的情况
	- 中介者模式可以降低多个对象和类之间的通信复杂度。这种模式提供了一个中介类，该类通常用于处理不同类之间的通信，降低类之间的耦合度，使代码易于维护
	
- 观察者模式（Observer）
	- 定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新
	
- 命令模式（Command）
	- 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化
	- 行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适

- 迭代器模式（Iterator）
	- 访问一个聚合对象的内容而无须暴露它的内部表示
	- 通过定义抽象的接口（具备next，first, hasNext方法），让各种具体结构来实现具体的迭代器
	
- 模板方法模式（Template Method）
	- 将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中
	
- 策略模式（Strategy）
	- 定义算法的抽象接口，使多组具体的算法实现可以相互替换使用
	
- 状态模式（State）
	- 将状态和相关的行为封装到一个通用抽象类中，调用者就不需要通过复杂的if-else来判断状态和手动调用行为，从而可以方便地增加和修改状态
	
- 备忘录模式（Memento）
	- 将对象的状态保存为一个具有抽象接口的备忘录对象，可以方便地记录状态和恢复状态
	- 所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态
	
- 解释器模式（Interpreter）
	- 对于一些固定文法构建一个解释句子的解释器
	
- 职责链模式（Chain of Responsibility）
	- 让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止
	- gin中的中间件就是职责链模式
	
- 访问者模式（Visitor）
	- 主要解决：稳定的数据结构和易变的操作耦合问题
	- 将易变的操作封装在一个抽象的访问者里，然后数据基础类里面有一个方法接受访问者，将自身引用传入访问者