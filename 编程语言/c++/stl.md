- STL中的vector与map底层原理
    - vector。vector是动态数组，通过预分配空间来降低二次分配的成本，当已分配空间不够用时，就需要重新分配空间，并把数据挪到新的空间去
    - map。map是一个键值存储，其底层实现是红黑树
  
    - [《C++ vector（STL vector）底层实现机制》](http://c.biancheng.net/view/6901.html)

- vector内存扩充的机制

- STL 中的内存管理(allocator)的原理, 以及如何让它线程安全
  
- STL 源码中的 hash 表的实现
    - 数据实际存放在与 hash 表存储单元相链接的链表中，而不是 hash 的存储单元中。 当产生冲突的时候，将两个数据都链接在同一 hash 存储单元保存的链表中。然后当插入元素的个数和表的大小一样时, 就让表的大小扩大为比最接近之前大小的两倍的质数大小。
    - 面试官顺着这个就问, 怎么找质数。我就简单地说了下筛选法的思路

- STL 的 unordered_map 和 map 的区别
    - 一个底层实现是哈希表, 一个是红黑树。由于底层实现的不同, 所以一个是有序, 一个是无序的。
    - 一个查找搜索复杂度是 O(1), 一个是O(logN).

- 介绍一下 STL 源码的内容

- map和hash_map

- map用find和[]的区别
  - 我说[]会返回一个左值引用，就算key不存在，也会用默认构造函数创建一个临时对象并返回它的引用，接着问如果这个对象的类没有默认构造函数怎么办？我说这样应该编译不会通过

- allocator，涉及到了内存池机制（优点、怎么做的）

- vector和list的区别，哪个对缓存更友好（空间局部性更好）

- map中为何使用红黑树而不是二叉平衡树
    - 红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树