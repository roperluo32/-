[TOC]

## C++特性
- C++面向对象的特性
    - 封装。可以隐藏实现细节，使得代码模块化
    - 继承。实现代码复用
    - 多态。实现即可复用
  
    - 参考： [《c++面向对象的三个特点，并简述》](https://blog.csdn.net/IOT_SHUN/article/details/79674293)

- C++ 语言的特性
    - C++ 是面向对象的语言, 自然有面向对象的语言的特性: 封装, 继承, 多态。
    - C++ 也是泛型编程语言, 自然也有泛型编程语言的特性。

- C++ 与 C 的区别
    - C++ 包含 C 几乎全部功能。
    - C++ 比 C 多面向对象语言部分。
    - C++ 比 C 多泛型编程部分。
    - C++ 比 C 多 STL 部分

## 基础知识
- volatile的作用    
    - 变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上
    - 在多线程中，volatile可以保证volatile修饰的变量不被编译器优化，每次读取都能从内存中读到原始值
    - 在编写多线程程序中使用volatile的关键四点：

      - 将所有的共享对象声明为volatile；

      - 不要将volatile直接作用于基本类型；

      - 当定义了共享类的时候，用volatile成员函数来保证线程安全；

      - 多多理解和使用volatile和LockingPtr！（强烈建议）
    - 参考
        - [《详解volatile在C++中的作用》](https://www.cnblogs.com/s5279551/archive/2010/09/19/1831258.html)

- extern关键字用法
    - extern 变量。表示声明的变量来自于其它文件
    - extern "C"。表示按照类C的编译和连接规约来编译和连接

- new和malloc的区别
![](http://images-1251273400.cosgz.myqcloud.com/20201011202812.png)
    - [《细说new与malloc的10点区别》](https://www.cnblogs.com/qg-whz/p/5140930.html)
- new一定会用到malloc吗？
    - 不一定，可以重载operator new，定义自己的内存分配
    - 重载new的场景
        - 检测代码中的内存错误
        - 优化性能
        - 获得内存使用的统计数据

- C++内存分配有哪些
    - 堆，栈，全局/静态存储区，自由存储区（由new分配的内存），常量存储区

- C与C++编译生成的符号表的区别
    - 符号表有内存地址和函数/变量的对应关系，编译时节点的各种属性（类型，作用域，分配空间大小，（函数）的参数类型）等

- 引用和指针的区别？
    - 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已
    - 可以有const指针，但是没有const引用；
    - 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
    - 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
    - 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
    - "sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
    - 指针和引用的自增(++)运算意义不一样

- 函数指针与指针函数分别是什么，函数指针与指针函数辨别
    - 指针函数即返回指针的函数
    ```c++
    int *pfun(int, int);
    ```
    - 指针函数。一个指向函数的指针
    ```c++
    int (*pfun)(int, int);
    ```
    通过括号强行将pfun首先与“*”结合，也就意味着，pfun是一个指针，接着与后面的“()”结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。
    - [《函数指针与指针函数》](http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/)

    
- inline内联函数是否可以递归
    - 函数的inline规范只是一个提示。 编译器可以（并且经常）完全忽略inline限定符的存在或不存在
    - 编译器可以选择有限地展开，或者完全采取不内联的方式（发现展开层次太多）

- 声明和定义的区别
    - 变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。  
    - 变量声明：用于向程序表明变量的类型和名字。  
    - 定义也是声明：当定义变量时我们声明了它的类型和名字。    
    - extern关键字：通过使用extern关键字声明变量名而不定义它
    - 一个变量只能定义一次，但可以声明多次

- 结构体的对齐方式？判断一个结构体的大小？如何强制不对齐？
    - 在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。
    - 为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”. 比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除.
    - 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐
    - __attribute__ ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐
    - [《C语言字节对齐、结构体对齐最详细的解释》](https://blog.csdn.net/lanzhihui_10086/article/details/44353381)
- 字节序的概念？（LINUX大端小端的概念，字节存储的顺序高低位）
    - 计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序
    - 人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存
    - [《理解字节序》](https://www.ruanyifeng.com/blog/2016/11/byte-order.html)

- 野指针的产生，危害，段错误怎么发生的？使用悬空指针一定会段错误吗？什么时候会，什么时候不会
    - 野指针是指向不可用内存区域的指针（非法内存，垃圾内存）。野指针不是NULL指针，是指向“垃圾”内存的指针
    - 产生原因：
        - 指针变量没有被初始化；没有初始化的指针值是随机的
        - 指针p被free/delete之后，没有置为NULL
        - 指针操作超越了变量的作用范围


- fwrite和write的区别，那是不是可以用write代替fwrite，read同理
    - fwrite和fread是带用户态缓冲的写和读
    - 以读为例，每次fread时，会从系统缓冲区中多读一些到用户态缓冲区，这样下次读的时候可以直接从用户态缓冲直接返回，而不需要陷入内核态读取

- memcpy与memmove的区别
    - memcpy不会检查src和dest是否重叠
    - memmove会检查src和dest重叠，因此是比较安全的
    ```c++
    #include <stddef.h> /* for size_t */
    void *memmove(void *dest, const void *src, size_t n)
    {
        unsigned char *pd = dest;
        const unsigned char *ps = src;
        if (__np_anyptrlt(ps, pd))
            for (pd += n, ps += n; n--;)
                *--pd = *--ps;
        else
            while(n--)
                *pd++ = *ps++;
        return dest;
    }
    ```
    - [《memcpy与memmove的区别》](https://www.jianshu.com/p/9c3784d8d8ad)
## 类
- class {} 内部实现的函数
    - 一般认为: 默认构造函数, 默认析构函数, 拷贝赋值函数, (移动构造函数, 移动赋值函数)
    - 《深度探索C++对象模型》中讲到, 不一定会生成这些函数, 然后blabla…(太多了, 这里不细说)

- 构造函数中是否能抛出异常

- C++中struct和class当作类使用时的区别
- 构造函数怎么做可以减少内存拷贝次数，与C++11无关，不要讲移动拷贝构造函数
- 空类是多大，能否实例化
- 讲一讲this指针
- C++中public，protected，private的区别，怎样可以访问protected
- this指针是怎么传进去的
- 讲一下C++ 类的内存布局，继承，多继承，虚继承
- 编译器默认初始化cpp空类几个函数（默认构造，默认拷贝构造，operator=，默认析构）
    - C++11可能会有默认移动构造） 编译器会生成6个成员函数： 一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个赋值运算符、两个取址运算符

- 成员初始化列表概念，可以在成员初始化列表中初始化父类成员吗？为什么

- C++的子类虚继承两个父类的内存模型。

- 在C++里面，怎样去重载new操作符？ （这里我回答的是写法）
    - 重载new有什么意义？引导-> 如果我已经有一块空间了，我想在已分配的空间上初始化一个对象，那应该怎么做。

- 拷贝构造函数应用场景。和operator = 的比较。有没有默认拷贝构造函数
    - （这里我感觉想问的是浅拷贝深拷贝，但是蒙了没回答好）

- class怎么防止继承


## 多态与虚函数
- 多态与虚函数
    - 多态。多态性(polymorphism)可以简单地概括为“一个接口，多种方法”。分为静态多态（函数重载）与动态多态（虚拟函数）
    - 虚函数。虚函数是C++中用于实现多态的机制，允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数
![](http://images-1251273400.cosgz.myqcloud.com/20201008154929.png)

- 虚函数表
    - C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

- 虚析构函数及其作用
    - 通过父指针释放对象时，能够调用到子对象的析构函数

- 虚函数与纯虚函数的区别
    - 虚函数。虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数
    - 纯虚函数。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理

- 哪些情况必须要把析构函数写成虚函数
    - 若存在类的继承关系,而且基类指针指向派生类对象时,一般需要将析构函数声明为虚函数,不然在使用基类指针进行析构时会无法调用派生类的析构函数而造成内存泄漏等问题

- 构造函数是否可以为虚函数
- 如果基类的析构函数没有声明为虚函数，会发生什么
- 基类里private成员函数可以声明为虚函数吗
- 多态的类型(静态、动态)， 分别如何实现
- 基类的虚函数有没有必要加virtual，为什么
- 菱形继承（虚基类指针） 虚基类指针指向哪个 简画子类对象内存
- 析构函数可以抛出异常吗

## static和const用法
- static的用法
    - 全局变量。该全局变量只能在当前文件访问，存储位置为全局（静态）存储区，即DATA段或BSS段
    - 局部变量。该局部变量的生命周期延长到程序结束
    - 函数。该函数只能在当前文件内访问
    - 类中的变量和函数。则该变量或函数所属于类，而不是类的实例。可以通过类直接调用static的变量和函数，static函数不能调用类的非static函数
    - 参考： 
        - [《const、static变量存放位置》](https://blog.csdn.net/lxw907304340/article/details/79982824)
        - [《C/C++ 中 static 的用法全局变量与局部变量》](https://www.runoob.com/w3cnote/cpp-static-usage.html)

- const用法
    - 普通变量
    - 指针变量。常量指针(const int *p)和指针常量(int * const p)
    - 函数的参数和返回值。对于函数参数，一般针对指针，防止被函数篡改；对于函数返回值，既不能被赋值，也不能被修改，以避免用户修改返回值
    - 类成员函数。避免类成员函数修改任何类成员
    - 参考：
        - [C++ const 关键字小结](https://www.runoob.com/w3cnote/cpp-const-keyword.html)

- const函数和非const函数可以实现重载吗？

## c++11
- c++11有哪些新特性
    - auto
    - 后置返回类型（方便模板定义的类型推导decltype）
    - 元组类型
    - lambda

    - 基于范围的for循环
    - 空指针常量nullptr （NULL是常量0，会造成一些类型错误。比如想要空指针类型，结果是int）
    - long long int 类型
    
    - 线程支持
    - 显式override和final（避免子类重写虚函数时意外地创建新的虚函数）
    - 模板别名

    - 参考：
        - [《十大必掌握C++11新特性》](https://blog.csdn.net/FX677588/article/details/70157088)

- auto怎么实现
- C++11里面auto有什么用，不给初始值可以吗

- std::enable_if了解吗

- 智能指针
    不需要手动去delete释放指针，退出作用域后自动释放（不管是正常退出，还是异常退出，类似golang的defer)
    有下面几种只能指针
    - auto_ptr。C++11中已经废弃。一个auto_ptr A赋值给auto_ptr B时，A会变成null指针，存在访问null指针导致程序崩溃的风险
    - unique_ptr。对于同一个指针，允许一个unique_ptr持有对其的引用，重复赋值会导致编译不通过。unique_ptr适用于比较固定的指针。
    - shared_ptr。允许多个shared_ptr指向同一个指针，内部采用引用计数来计算对指针的引用数，当引用数为0时，指针就会被释放
    - 参考
        - [《C++中的智能指针》](https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=31357&query=&asc=true&order=&page=35)

- 用过shared_ptr和weak_ptr吗？为什么要搭配使用？看过shared_ptr的源码吗？说一下
- weak_ptr用在什么场景？为什么要用weak_ptr?
- std::move的作用与意义是什么
- 有用过std::thread和std::bind吗，知道std::placeholders实现原理吗
- 讲讲std::thread 和操作系统级别的线程有什么区别
- 了解C++11 的原子操作吗，C++11多线程内存模型知道吗
- 智能指针的shared_pr 写下代码
- share_ptr一定能保证内存不泄露吗？写代码说明（写完以后又问了如何避免）
- 智能指针（unique_ptr，shared_ptr）循环引用（weak_ptr）为什么叫弱引用

- 智能指针，引用计数，什么时候++，--，werk_ptr有什么用，怎么用

- 用过shared_ptr和weak_ptr吗？为什么要搭配使用？看过shared_ptr的源码吗

- unique_ptr怎么实现，独占，数组等
- nullptr比NULL优势（指针地址和整数的歧义？）

- 智能指针的实现原理是什么

- auto关键字用过吗，类型推导有什么限制。如果用来声明函数要注意什么
- RAII是什么？全称呢？和智能指针什么关系

- shared_ptr、unique_ptr是线程安全的吗，底层实现

- shared_ptr循环引用，a->b,b->a,最后引用计数是多少

- 左值与右值,左值引用与右值引用
    - 左值就是有名字的变量，可以被赋值
    - 右值就是临时变量（对象），没有名字，不能被赋值
    - 左值引用就是平时看到的引用，是对左值的引用
    - 右值引用是c++11中增加的特性，用&&符号表示。用来延长右值的生命周期，减少临时对象的生成
    - [《C++ 11 左值，右值，左值引用，右值引用》](https://blog.csdn.net/xiaolewennofollow/article/details/52559306)

- std里的bind()使用成员函数和普通函数有什么区别？
    - 使用成员函数需要注意补充this参数
    - [《C++11 中std::function和std::bind的用法》](https://blog.csdn.net/liukang325/article/details/53668046)

## 模板
- 模板了解多少
- 模板偏特化了解吗




## 多线程和锁
- unique_lock和lock_guard的区别
- pthread_once的作用及实现
- 条件变量应用场景
- 线程池怎么使用锁，muduo中是使用什么锁，使用的是互斥锁，并不是使用读写锁。
- 对比过muduo的异步日志效率跟别的日志系统吗？
- 线程池是怎么实现的?线程池是用自己写的还是用的系统api
- 两个线程什么情况会出现死锁
- 如何控制线程执行顺序
- 无锁编程，release acquire语义




