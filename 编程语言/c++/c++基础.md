[TOC]

## C++特性
- C++面向对象的特性
    - 封装。可以隐藏实现细节，使得代码模块化
    - 继承。实现代码复用
    - 多态。实现即可复用
  
    - 参考： [《c++面向对象的三个特点，并简述》](https://blog.csdn.net/IOT_SHUN/article/details/79674293)

- C++ 语言的特性
    - C++ 是面向对象的语言, 自然有面向对象的语言的特性: 封装, 继承, 多态。
    - C++ 也是泛型编程语言, 自然也有泛型编程语言的特性。

- C++ 与 C 的区别
    - C++ 包含 C 几乎全部功能。
    - C++ 比 C 多面向对象语言部分。
    - C++ 比 C 多泛型编程部分。
    - C++ 比 C 多 STL 部分

## 基础知识
- volatile的作用    
    - 变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上
    - 在多线程中，volatile可以保证volatile修饰的变量不被编译器优化，每次读取都能从内存中读到原始值
    - 在编写多线程程序中使用volatile的关键四点：

      - 将所有的共享对象声明为volatile；

      - 不要将volatile直接作用于基本类型；

      - 当定义了共享类的时候，用volatile成员函数来保证线程安全；

      - 多多理解和使用volatile和LockingPtr！（强烈建议）
    - 参考
        - [《详解volatile在C++中的作用》](https://www.cnblogs.com/s5279551/archive/2010/09/19/1831258.html)

- extern关键字用法
    - extern 变量。表示声明的变量来自于其它文件
    - extern "C"。表示按照类C的编译和连接规约来编译和连接

- new和malloc的区别
![](http://images-1251273400.cosgz.myqcloud.com/20201011202812.png)
    - [《细说new与malloc的10点区别》](https://www.cnblogs.com/qg-whz/p/5140930.html)
- new一定会用到malloc吗？
    - 不一定，可以重载operator new，定义自己的内存分配
    - 重载new的场景
        - 检测代码中的内存错误
        - 优化性能
        - 获得内存使用的统计数据
- 在C++里面，怎样去重载new操作符？ （这里我回答的是写法）
    - 全局重载
    ![](http://images-1251273400.cosgz.myqcloud.com/20201012222221.png)
    - 类中的局部重载
    ![](http://images-1251273400.cosgz.myqcloud.com/20201012222254.png)

- C++内存分配有哪些
    - 堆，栈，全局/静态存储区，自由存储区（由new分配的内存），常量存储区

- C与C++编译生成的符号表的区别
    - 符号表有内存地址和函数/变量的对应关系，编译时节点的各种属性（类型，作用域，分配空间大小，（函数）的参数类型）等

- 引用和指针的区别？
    - 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已
    - 可以有const指针，但是没有const引用；
    - 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
    - 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
    - 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
    - "sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
    - 指针和引用的自增(++)运算意义不一样

- 函数指针与指针函数分别是什么，函数指针与指针函数辨别
    - 指针函数即返回指针的函数
    ```c++
    int *pfun(int, int);
    ```
    - 指针函数。一个指向函数的指针
    ```c++
    int (*pfun)(int, int);
    ```
    通过括号强行将pfun首先与“*”结合，也就意味着，pfun是一个指针，接着与后面的“()”结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。
    - [《函数指针与指针函数》](http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/)

    
- inline内联函数是否可以递归
    - 函数的inline规范只是一个提示。 编译器可以（并且经常）完全忽略inline限定符的存在或不存在
    - 编译器可以选择有限地展开，或者完全采取不内联的方式（发现展开层次太多）

- 声明和定义的区别
    - 变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。  
    - 变量声明：用于向程序表明变量的类型和名字。  
    - 定义也是声明：当定义变量时我们声明了它的类型和名字。    
    - extern关键字：通过使用extern关键字声明变量名而不定义它
    - 一个变量只能定义一次，但可以声明多次

- 结构体的对齐方式？判断一个结构体的大小？如何强制不对齐？
    - 在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。
    - 为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”. 比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除.
    - 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐
    - __attribute__ ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐
    - [《C语言字节对齐、结构体对齐最详细的解释》](https://blog.csdn.net/lanzhihui_10086/article/details/44353381)
- 字节序的概念？（LINUX大端小端的概念，字节存储的顺序高低位）
    - 计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序
    - 人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存
    - [《理解字节序》](https://www.ruanyifeng.com/blog/2016/11/byte-order.html)

- 野指针的产生，危害，段错误怎么发生的？使用悬空指针一定会段错误吗？什么时候会，什么时候不会
    - 野指针是指向不可用内存区域的指针（非法内存，垃圾内存）。野指针不是NULL指针，是指向“垃圾”内存的指针
    - 产生原因：
        - 指针变量没有被初始化；没有初始化的指针值是随机的
        - 指针p被free/delete之后，没有置为NULL
        - 指针操作超越了变量的作用范围


- fwrite和write的区别，那是不是可以用write代替fwrite，read同理
    - fwrite和fread是带用户态缓冲的写和读
    - 以读为例，每次fread时，会从系统缓冲区中多读一些到用户态缓冲区，这样下次读的时候可以直接从用户态缓冲直接返回，而不需要陷入内核态读取

- memcpy与memmove的区别
    - memcpy不会检查src和dest是否重叠
    - memmove会检查src和dest重叠，因此是比较安全的
    ```c++
    #include <stddef.h> /* for size_t */
    void *memmove(void *dest, const void *src, size_t n)
    {
        unsigned char *pd = dest;
        const unsigned char *ps = src;
        if (__np_anyptrlt(ps, pd))
            for (pd += n, ps += n; n--;)
                *--pd = *--ps;
        else
            while(n--)
                *pd++ = *ps++;
        return dest;
    }
    ```
    - [《memcpy与memmove的区别》](https://www.jianshu.com/p/9c3784d8d8ad)


## 类
- class {} 内部实现的函数
    - 一般认为: 默认构造函数, 默认析构函数, 拷贝赋值函数, (移动构造函数, 移动赋值函数)
    - 《深度探索C++对象模型》中讲到, 不一定会生成这些函数, 然后blabla…(太多了, 这里不细说)
    - 构造函数、析构函数、拷贝构造函数、赋值运算符重载函数、取地址操作符重载、const修饰的取地址操作符重载
    - [《详解c++中类的六个默认的成员函数》](https://blog.csdn.net/peiyao456/article/details/51834981)


- 构造函数中是否能抛出异常
    - 构造函数中抛出异常，会导致析构函数不能被调用，所以可能会造成内存泄露或系统资源未被释放
    - 析构函数的执行不应该抛出异常。发生异常时会调用析构函数释放资源，此时如果再发生异常，系统将变得非常危险，也许很长时间什么错误也不会发生；但也许你的系统有时就会莫名奇妙地崩溃而退出了，而且什么迹象也没有
    - [《C++中构造函数和析构函数抛出异常问题》](https://blog.csdn.net/u012611878/article/details/78945586)

- C++中struct和class当作类使用时的区别
    - 默认的继承访问权限。struct是public的，class是private的
    - struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的

- 构造函数怎么做可以减少内存拷贝次数，与C++11无关，不要讲移动拷贝构造函数


- 讲一讲this指针
    - 对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果
    - 编译器自动为类的非静态函数插入隐含的this指针参数
    - this只能在成员函数中使用
    - this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量
    - [《C++中this指针的用法详解》](http://blog.chinaunix.net/uid-21411227-id-1826942.html)

- this指针是怎么传进去的
    - 编译器在编译的时候，就把this指针以参数的形式传递给了成员函数

- C++中public，protected，private的区别，怎样可以访问protected
    - private,public,protected的访问范围:
        - private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.
        - protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
        - public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问
        - 注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数
    - 类的继承后方法属性变化
        - 使用private继承,父类的所有方法在子类中变为private;
        - 使用protected继承,父类的protected和public方法在子类中变为protected,private方法不变;
        - 使用public继承,父类中的方法属性不发生改变;
    - [《C++中public、protected、private的区别》](https://blog.csdn.net/scottly1/article/details/24354489)


- 成员初始化列表概念，可以在成员初始化列表中初始化父类成员吗？为什么
    - 不可以，因为成员初始化列表是成员定义+赋值两个操作，因此在初始化列表中初始化父类成员相当于会把父类成员重复定义一次，肯定会报错
    - 由于构造函数内的初始化相当于赋值了，所以为了效率，以及某些情况必须使用成员初始化列表，有如下几种情况：
        - 需要初始化的数据成员是对象的情况（为了效率，避免执行拷贝构造和赋值构造函数）
        - 需要初始化const修饰的类成员
        - 需要初始化引用成员数据


- 拷贝构造函数应用场景。和operator = 的比较。有没有默认拷贝构造函数
    - 拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。
    - 拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例
    - 赋值运算符是执行某种运算，将一个对象的值复制给另一个对象
    - 调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生
    - 调用拷贝构造函数主要有以下场景
        - 对象作为函数的参数，以值传递的方式传给函数。　
        - 对象作为函数的返回值，以值的方式从函数返回
        - 使用一个对象给另一个对象初始化
    - [《C++ 拷贝构造函数和赋值运算符》](https://www.cnblogs.com/wangguchangqing/p/6141743.html)

- 空类是多大，能否实例化
    - 空类实例化后的大小为1，是为了取地址时能取到地址
    - 类的大小：
        - 为类的非静态成员数据的类型大小之和．    
        - 有编译器额外加入的成员变量的大小，用来支持语言的某些特性（如：指向虚函数的指针）
        - 为了优化存取效率，进行的边缘调整． 
        - 与类中的构造函数，析构函数以及其他的成员函数无关
    - [《sizeof 空类》](https://www.cnblogs.com/my_life/articles/3716594.html)

- 什么是虚拟继承
    - 虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示
    ![](http://images-1251273400.cosgz.myqcloud.com/20201012223733.png)
    - [《C++ 虚拟继承》](https://www.cnblogs.com/heyonggang/p/3255155.html)

- 讲一下C++ 类的内存布局，继承，多继承，虚继承
- C++的子类虚继承两个父类的内存模型。
    - [《(好)C++ 多继承和虚继承的内存布局》](https://blog.csdn.net/yockie/article/details/50603236)

- 编译器默认初始化cpp空类几个函数（默认构造，默认拷贝构造，operator=，默认析构）
    - C++11可能会有默认移动构造） 编译器会生成6个成员函数： 一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个赋值运算符、两个取址运算符

- class怎么防止继承
    - 不能直接将类的构造函数设为private，因为这样的话，这个类也无法实例化对象，没有意义
    ![](http://images-1251273400.cosgz.myqcloud.com/20201012223501.png)
    - [《c++如何防止一个类被其他类继承》](https://blog.csdn.net/zhang1308299607/article/details/76100430)

## 多态与虚函数
- 多态与虚函数
    - 多态。多态性(polymorphism)可以简单地概括为“一个接口，多种方法”。分为静态多态（函数重载）与动态多态（虚拟函数）
    - 虚函数。虚函数是C++中用于实现多态的机制，允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数
![](http://images-1251273400.cosgz.myqcloud.com/20201008154929.png)

- 虚函数表
    - C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

- 虚析构函数及其作用
    - 通过父指针释放对象时，能够调用到子对象的析构函数
- 如果基类的析构函数没有声明为虚函数，会发生什么
    - 会直接调用掉基类的析构函数，无法执行子类的析构函数造成内存泄露

- 虚函数与纯虚函数的区别
    - 虚函数。虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数
    - 纯虚函数。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理

- 哪些情况必须要把析构函数写成虚函数
    - 若存在类的继承关系,而且基类指针指向派生类对象时,一般需要将析构函数声明为虚函数,不然在使用基类指针进行析构时会无法调用派生类的析构函数而造成内存泄漏等问题

- 构造函数是否可以为虚函数
    - 构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型
    - 从存储空间角度，虚函数对应一个指向vtable虚函数表的指针；如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢
    - [《构造函数为什么不能是虚函数》](https://www.cnblogs.com/youxin/p/4355946.html)

- 基类里private成员函数可以声明为虚函数吗
- 多态的类型(静态、动态)， 分别如何实现
- 基类的虚函数有没有必要加virtual，为什么
- 菱形继承（虚基类指针） 虚基类指针指向哪个 简画子类对象内存
- 析构函数可以抛出异常吗

## static和const用法
- static的用法
    - 全局变量。该全局变量只能在当前文件访问，存储位置为全局（静态）存储区，即DATA段或BSS段
    - 局部变量。该局部变量的生命周期延长到程序结束
    - 函数。该函数只能在当前文件内访问
    - 类中的变量和函数。则该变量或函数所属于类，而不是类的实例。可以通过类直接调用static的变量和函数，static函数不能调用类的非static函数
    - 参考： 
        - [《const、static变量存放位置》](https://blog.csdn.net/lxw907304340/article/details/79982824)
        - [《C/C++ 中 static 的用法全局变量与局部变量》](https://www.runoob.com/w3cnote/cpp-static-usage.html)

- const用法
    - 普通变量
    - 指针变量。常量指针(const int *p)和指针常量(int * const p)
    - 函数的参数和返回值。对于函数参数，一般针对指针，防止被函数篡改；对于函数返回值，既不能被赋值，也不能被修改，以避免用户修改返回值
    - 类成员函数。避免类成员函数修改任何类成员
    - 参考：
        - [C++ const 关键字小结](https://www.runoob.com/w3cnote/cpp-const-keyword.html)

- const函数和非const函数可以实现重载吗？

## c++11
- c++11有哪些新特性
    - auto
    - 后置返回类型（方便模板定义的类型推导decltype）
    - 元组类型
    - lambda

    - 基于范围的for循环
    - 空指针常量nullptr （NULL是常量0，会造成一些类型错误。比如想要空指针类型，结果是int）
    - long long int 类型
    - std::bind和std::function函数封装器

    - 线程支持
    - 显式override和final（避免子类重写虚函数时意外地创建新的虚函数）
    - 模板别名

    - 参考：
        - [《十大必掌握C++11新特性》](https://blog.csdn.net/FX677588/article/details/70157088)

- auto怎么实现
- C++11里面auto有什么用，不给初始值可以吗

- std::enable_if了解吗

- 智能指针
    不需要手动去delete释放指针，退出作用域后自动释放（不管是正常退出，还是异常退出，类似golang的defer)
    有下面几种只能指针
    - auto_ptr。C++11中已经废弃。一个auto_ptr A赋值给auto_ptr B时，A会变成null指针，存在访问null指针导致程序崩溃的风险
    - unique_ptr。对于同一个指针，允许一个unique_ptr持有对其的引用，重复赋值会导致编译不通过。unique_ptr适用于比较固定的指针。
    - shared_ptr。允许多个shared_ptr指向同一个指针，内部采用引用计数来计算对指针的引用数，当引用数为0时，指针就会被释放
    - 参考
        - [《C++中的智能指针》](https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=31357&query=&asc=true&order=&page=35)

- 用过shared_ptr和weak_ptr吗？为什么要搭配使用？看过shared_ptr的源码吗？说一下
- weak_ptr用在什么场景？为什么要用weak_ptr?
- std::move的作用与意义是什么
- 有用过std::thread和std::bind吗，知道std::placeholders实现原理吗
- 讲讲std::thread 和操作系统级别的线程有什么区别
- 了解C++11 的原子操作吗，C++11多线程内存模型知道吗
- 智能指针的shared_pr 写下代码
- share_ptr一定能保证内存不泄露吗？写代码说明（写完以后又问了如何避免）
- 智能指针（unique_ptr，shared_ptr）循环引用（weak_ptr）为什么叫弱引用

- 智能指针，引用计数，什么时候++，--，werk_ptr有什么用，怎么用

- 用过shared_ptr和weak_ptr吗？为什么要搭配使用？看过shared_ptr的源码吗

- unique_ptr怎么实现，独占，数组等
- nullptr比NULL优势（指针地址和整数的歧义？）

- 智能指针的实现原理是什么

- auto关键字用过吗，类型推导有什么限制。如果用来声明函数要注意什么
- RAII是什么？全称呢？和智能指针什么关系

- shared_ptr、unique_ptr是线程安全的吗，底层实现

- shared_ptr循环引用，a->b,b->a,最后引用计数是多少

- 左值与右值,左值引用与右值引用
    - 左值就是有名字的变量，可以被赋值
    - 右值就是临时变量（对象），没有名字，不能被赋值
    - 左值引用就是平时看到的引用，是对左值的引用
    - 右值引用是c++11中增加的特性，用&&符号表示。用来延长右值的生命周期，减少临时对象的生成
    - [《C++ 11 左值，右值，左值引用，右值引用》](https://blog.csdn.net/xiaolewennofollow/article/details/52559306)

- std里的bind()使用成员函数和普通函数有什么区别？
    - 使用成员函数需要注意补充this参数
    - [《C++11 中std::function和std::bind的用法》](https://blog.csdn.net/liukang325/article/details/53668046)

## 模板
- 模板了解多少
- 模板偏特化了解吗




## 多线程和锁
- unique_lock和lock_guard的区别
- pthread_once的作用及实现
- 条件变量应用场景
- 线程池怎么使用锁，muduo中是使用什么锁，使用的是互斥锁，并不是使用读写锁。
- 对比过muduo的异步日志效率跟别的日志系统吗？
- 线程池是怎么实现的?线程池是用自己写的还是用的系统api
- 两个线程什么情况会出现死锁
- 如何控制线程执行顺序
- 无锁编程，release acquire语义




