[TOC]

## C++特性
- C++面向对象的特性
    - 封装。可以隐藏实现细节，使得代码模块化
    - 继承。实现代码复用
    - 多态。实现即可复用
  
    - 参考： [《c++面向对象的三个特点，并简述》](https://blog.csdn.net/IOT_SHUN/article/details/79674293)

- C++ 语言的特性
    - C++ 是面向对象的语言, 自然有面向对象的语言的特性: 封装, 继承, 多态。
    - C++ 也是泛型编程语言, 自然也有泛型编程语言的特性。

- C++ 与 C 的区别
    - C++ 包含 C 几乎全部功能。
    - C++ 比 C 多面向对象语言部分。
    - C++ 比 C 多泛型编程部分。
    - C++ 比 C 多 STL 部分

## 基础知识
- volatile的作用
- extern关键字用法

- new和malloc的区别
- C++内存分配有哪些

- C与C++编译生成的符号表的区别
- 引用和指针的区别？

- 函数指针与指针函数分别是什么，函数指针与指针函数辨别
- 左值右值的区别
- inline内联函数是否可以递归
- std里的bind()使用成员函数和普通函数有什么区别？
- cpp内存泄漏检查（手动封装malloc打印文件行数，动态检查valgrind，语言层面避免，比如智能指针）


## 类
- class {} 内部实现的函数
    - 一般认为: 默认构造函数, 默认析构函数, 拷贝赋值函数, (移动构造函数, 移动赋值函数)
    - 《深度探索C++对象模型》中讲到, 不一定会生成这些函数, 然后blabla…(太多了, 这里不细说)

- 构造函数中是否能抛出异常

- C++中struct和class当作类使用时的区别
- 构造函数怎么做可以减少内存拷贝次数，与C++11无关，不要讲移动拷贝构造函数
- 空类是多大，能否实例化
- 讲一讲this指针
- C++中public，protected，private的区别，怎样可以访问protected
- this指针是怎么传进去的
- 讲一下C++ 类的内存布局，继承，多继承，虚继承
- 编译器默认初始化cpp空类几个函数（默认构造，默认拷贝构造，operator=，默认析构）
    - C++11可能会有默认移动构造） 编译器会生成6个成员函数： 一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个赋值运算符、两个取址运算符




## 多态与虚函数
- 多态与虚函数
    - 多态。多态性(polymorphism)可以简单地概括为“一个接口，多种方法”。分为静态多态（函数重载）与动态多态（虚拟函数）
    - 虚函数。虚函数是C++中用于实现多态的机制，允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数
![](http://images-1251273400.cosgz.myqcloud.com/20201008154929.png)

- 虚函数表
    - C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

- 虚析构函数及其作用
    - 通过父指针释放对象时，能够调用到子对象的析构函数

- 虚函数与纯虚函数的区别
    - 虚函数。虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数
    - 纯虚函数。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理

- 哪些情况必须要把析构函数写成虚函数
    - 若存在类的继承关系,而且基类指针指向派生类对象时,一般需要将析构函数声明为虚函数,不然在使用基类指针进行析构时会无法调用派生类的析构函数而造成内存泄漏等问题

- 构造函数是否可以为虚函数
- 如果基类的析构函数没有声明为虚函数，会发生什么
- 基类里private成员函数可以声明为虚函数吗
- 多态的类型(静态、动态)， 分别如何实现
- 基类的虚函数有没有必要加virtual，为什么
- 菱形继承（虚基类指针） 虚基类指针指向哪个 简画子类对象内存


## static和const用法
- static的用法
    - 全局变量。该全局变量只能在当前文件访问，存储位置为全局（静态）存储区，即DATA段或BSS段
    - 局部变量。该局部变量的生命周期延长到程序结束
    - 函数。该函数只能在当前文件内访问
    - 类中的变量和函数。则该变量或函数所属于类，而不是类的实例。可以通过类直接调用static的变量和函数，static函数不能调用类的非static函数
    - 参考： 
        - [《const、static变量存放位置》](https://blog.csdn.net/lxw907304340/article/details/79982824)
        - [《C/C++ 中 static 的用法全局变量与局部变量》](https://www.runoob.com/w3cnote/cpp-static-usage.html)

- const用法
    - 普通变量
    - 指针变量。常量指针(const int *p)和指针常量(int * const p)
    - 函数的参数和返回值。对于函数参数，一般针对指针，防止被函数篡改；对于函数返回值，既不能被赋值，也不能被修改，以避免用户修改返回值
    - 类成员函数。避免类成员函数修改任何类成员
    - 参考：
        - [C++ const 关键字小结](https://www.runoob.com/w3cnote/cpp-const-keyword.html)

- const函数和非const函数可以实现重载吗？

## c++11
- c++11有哪些新特性
    - auto
    - 后置返回类型（方便模板定义的类型推导decltype）
    - 元组类型
    - lambda

    - 基于范围的for循环
    - 空指针常量nullptr （NULL是常量0，会造成一些类型错误。比如想要空指针类型，结果是int）
    - long long int 类型
    
    - 线程支持
    - 显式override和final（避免子类重写虚函数时意外地创建新的虚函数）
    - 模板别名

    - 参考：
        - [《十大必掌握C++11新特性》](https://blog.csdn.net/FX677588/article/details/70157088)

- auto怎么实现
- C++11里面auto有什么用，不给初始值可以吗

- std::enable_if了解吗

- 智能指针
    不需要手动去delete释放指针，退出作用域后自动释放（不管是正常退出，还是异常退出，类似golang的defer)
    有下面几种只能指针
    - auto_ptr。C++11中已经废弃。一个auto_ptr A赋值给auto_ptr B时，A会变成null指针，存在访问null指针导致程序崩溃的风险
    - unique_ptr。对于同一个指针，允许一个unique_ptr持有对其的引用，重复赋值会导致编译不通过。unique_ptr适用于比较固定的指针。
    - shared_ptr。允许多个shared_ptr指向同一个指针，内部采用引用计数来计算对指针的引用数，当引用数为0时，指针就会被释放
    - 参考
        - [《C++中的智能指针》](https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=31357&query=&asc=true&order=&page=35)

- 用过shared_ptr和weak_ptr吗？为什么要搭配使用？看过shared_ptr的源码吗？说一下
- weak_ptr用在什么场景？为什么要用weak_ptr?
- std::move的作用与意义是什么
- 有用过std::thread和std::bind吗，知道std::placeholders实现原理吗
- 讲讲std::thread 和操作系统级别的线程有什么区别
- 了解C++11 的原子操作吗，C++11多线程内存模型知道吗
- 智能指针的shared_pr 写下代码
- share_ptr一定能保证内存不泄露吗？写代码说明（写完以后又问了如何避免）
- 智能指针（unique_ptr，shared_ptr）循环引用（weak_ptr）为什么叫弱引用

- 智能指针，引用计数，什么时候++，--，werk_ptr有什么用，怎么用

- 用过shared_ptr和weak_ptr吗？为什么要搭配使用？看过shared_ptr的源码吗

- unique_ptr怎么实现，独占，数组等
- nullptr比NULL优势（指针地址和整数的歧义？）

- 智能指针的实现原理是什么

- auto关键字用过吗，类型推导有什么限制。如果用来声明函数要注意什么
- RAII是什么？全称呢？和智能指针什么关系

- shared_ptr、unique_ptr是线程安全的吗，底层实现

## 模板
- 模板了解多少
- 模板偏特化了解吗







## 多线程和锁
- unique_lock和lock_guard的区别
- pthread_once的作用及实现
- 条件变量应用场景
- 线程池怎么使用锁，muduo中是使用什么锁，使用的是互斥锁，并不是使用读写锁。
- 对比过muduo的异步日志效率跟别的日志系统吗？
- 线程池是怎么实现的?线程池是用自己写的还是用的系统api
- 两个线程什么情况会出现死锁
- 如何控制线程执行顺序



