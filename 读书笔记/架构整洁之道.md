# 第1部分 概述

- 软件架构的终极目标：用最小的人力成本来满足构建和维护系统的需求
- 慢就是稳。反例：我们可以未来再重构代码，产品上线最重要。胡乱编写代码的工作速度其实比循规蹈矩要慢

- 两个价值维度
    - 行为价值。即软件的功能，也是业务人员和客户最关注的的部分。
    - 架构价值。架构人员应该最关注的，并且要坚持维护好的架构。好的架构对后续的功能扩展，运维都非常有意义


# 第2部分 从基础构建开始：编程范式
- 结构化编程。对程序控制权的直接转移做了限制和规范
    - 功能性拆解的能力
    - 拆解后的子单元可证伪
- 面向对象编程。对程序控制权的间接转移做了限制和规范
    - 封装和继承不是面向对象编程的特点，早在C语言中就有体现
    - 多态。C语言中通过函数指针也可以实现多态，不过面向对象编程对其做了良好的封装，使架构设计师能够更安全地使用多态，是一个很大的进步
    - 多态可以方便地实现依赖反转
    
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200128203908.png)
- 函数编程。对程序的赋值做了限制和规范
    - 函数编程中的变量是不可变的
    - 不可变性对软件架构也是非常有意义的。比如LSM(日志结构合并树)，Raft的日志状态机，Git版本管理等，都利用记录的不可变性，来简化了数据的维护
    - 不可变性意味着不需要锁和并发控制
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200128204310.png)
- 这三种编程范式和架构的三个关注点不谋而合：功能性，组件独立性，数据管理


# 第3部分 设计原则
- SOLID。告诉我们怎么将数据和函数组织成类。也就是模块级编程（更高级别的是组件编程）
   - 单一职责，开闭原则，里氏替换原则，接口隔离，依赖反转
- 单一职责原则(SRP)。每个软件模块有且只有一个被改变的理由，模块只对一个修改者负责。下面是一个反例
   
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200128205645.png)
- 开闭原则(OCP)。对修改关闭，对扩展开放。与函数编程的不可变性是相通的
- 里氏替换原则(LSP)。组件必须遵守一定的规定，以使其可以被相互替换
- 接口隔离(ISP)。接口之间应该保持隔离，以使依赖方不需要依赖不需要的接口
- 依赖反转(DIP)。底层模块的具体实现应该依赖高层模块的接口
   - 应避免在代码中引入任何与具体相关的名字
   - 使用抽象工厂模式去隔离具体对象的创建
  

# 第4部分 组件构建原则
- SOLID原则指导怎么将砖头（函数和数据）砌成房间（模块和类，组件），那么组件构建原则就是指导怎么将房间（组件）构建成房子（软件系统）
- 组件是软件的部署单元，是可以独立部署的最小单元，可以是jar，dll，或者exe

### 组件聚合
- REP 复用/发布等同原则。软件复用的最小粒度应等同于其发布的最小粒度
    - 如果要复用组件，就需要组件遵循某种发布流程，有明确的版本号
    - 组件中的类和函数必须是紧密相连的，有一个共同主题或者大方向

- CCP 共同闭包原则。将会同时修改，会为同一目的修改的类放到同一个组件
    - 与单一职责原则（SRP）类似，一个组件不应该存在多个变更原因
    - 强调可维护性高于可复用性
    - 将某一变更涉及到的类聚合到一个组件中，尽量减少变更的影响范围
- CRP 共同复用原则。不要强迫组件的用户依赖它们不需要的东西
    - 告诉我们应该将哪些类分开
    - 与接口隔离原则（ISP）是一致的，不要依赖不需要用到的东西

    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200128213158.png)
    
- **怎么抉择**？前期CCP（可维护性）比CRP（可复用）重要，因此可以牺牲一定的可复用性，后期组件越来越复杂，需要注重复用性


### 组件耦合
- 无依赖环原则。组件依赖图中不应该出现环

  ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200128214015.png)
  
- 自上而下的设计。 组件结构图不可能自上而下设计出来，它是随着系统的变化而变化和扩张
   - 组件依赖结构图不是用来描述应用程序功能的，它是应用程序在构建性和维护性方面的一张地图
- SDP 稳定依赖原则。依赖关系必须指向更稳定的方向
    - 什么是稳定性？稳定意味着很难移动，代码很难修改。让组件难于修改的一个最直接方法就是，让很多组件依赖于它
    
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200128214719.png)

    - 不稳定性指标。I = Fan-out/(Fan-out + Fan-in)
- SAP 稳定抽象原则。一个组件的抽象化程度应该与其稳定性一致
    - 依赖关系应该指向更抽象的方向
    
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200128215433.png)


# 第5部分 软件架构
- 软件架构的实质就是规划如何将系统划分成组件，并安排好组件的排列关系，以及组件之间的互相通信
- 良好设计的关键在于，尽可能长时间地**保留尽量多的选项**（数据库，web框架，REST模式，HTML/IOS/ANDROID，单体/多线程/多进程/微服务）
- 一个优秀的软件设计师应该**致力于最大化可选项的数量**

- 用例（尖叫的架构）。好的架构应该直观地反映出用例的元素，比如一个购物车应用，应该从架构上可以清晰地看出来这是一个购物车应用，类和组件名称应该是购物车的元素

- 运行。架构应该灵活支持单体/多线程/多进程/微服务框架，从而能够灵活地支持多种量级的请求量

- 部署
    - 好的架构应该不依赖一大堆脚本和配置文件，也不需要用户去创建一堆有严格要求的目录和文件
    - 通过良好地隔离组件来实现，包括实现一些主组件，将整个系统黏合在一起，正确地启动，监控这些组件

- 解耦
    - 提前知晓所有的用例是不可能的，但是可以根据应用的意图提前对其进行解耦，将不同变更原因，不同吞吐量的模块进行独立解耦
    - 按层解耦（水平解耦）。将业务分成UI界面，应用独有的业务逻辑，领域普适的业务逻辑，数据库等
    - 用例解耦（垂直解耦）。比如增加订单的用例，删除订单的用例
    - 按照吞吐量大小解耦。方便部署运行，节省资源
    - 项目初期应该保持单体应用尽量久的时间。但是保持架构的解耦程度，保证可以随时切换到服务方式

    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129113051.png)

    - **解耦模式也是一个可选项**


- 划分边界
    - 软件架构本身就是一门划分边界的艺术
    - 最消耗人力资源的是什么？系统中的耦合，尤其是那些过早做出的，不成熟的决策导致的耦合
    - 哪些决策被认为是不成熟的？那些与业务需求（用例）无关的决策（比如数据库，框架，web服务器，工具，依赖注入）

    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129114438.png) 

- 插件式架构。UI和数据库应该都依赖业务逻辑的接口，成为业务逻辑的插件
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129114633.png)

- 业务逻辑。业务逻辑是整个系统中的皇冠明珠，这部分逻辑应该保持纯净，不要掺杂任何用户界面以及数据库相关的东西。其它底层逻辑应该以插件的形式接入业务逻辑中。业务逻辑应该是系统中最独立，复用性最高的代码

- 可测试的架构设计
    - 用例的单元测试可以不依赖框架（不需要启动web），不依赖特定数据库（启动mysql）
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129203524.png)
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129203546.png)
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129203631.png)
    - 谦卑对象模式
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129203808.png)

- 不完全边界
    - 构建完整边界是一件成本很高的事情（设计多态）
   ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129204017.png)
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129204114.png)
    - 使用facede模式（门户模式），去掉依赖反转
    ![](https://raw.githubusercontent.com/roperluo32/images/master/image20200129204404.png)

    - main组件是架构中最具体的组件


# 第6部分  实现细节
- 数据库是实现细节
- web是实现细节
- 应用程序框架是实现细节