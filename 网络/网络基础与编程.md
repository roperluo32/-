## TCP三次握手和四次挥手
- TCP三次握手过程
![](http://images-1251273400.cosgz.myqcloud.com/2b7a6de6-58e4-43a5-82b1-ad06b81b06f0.jpg)
- TCP的四次挥手
![](http://images-1251273400.cosgz.myqcloud.com/df903199-8c0a-4aeb-b56a-0c5372f8c9b6.jpg)

- 四次挥手中，TIME-WAIT状态是在哪一步？
  - 主动发起close的一方，收到被动方的FIN后，主动方就会进入TIME_WAIT状态

- TIME-WAIT状态下的等待时间是多少？为何是2MSL?
  - MSL。即为Max Segment Lifetime, 一个包在网络上生存的最长时间，默认是120s
  - 为何是2MSL，需要确认主动方重复发送的ACK和被动方重复发送的FIN在网络上彻底消亡


- 什么时候会收到RST报文段
  - RST标示复位、用来异常的关闭连接。
    - 发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST
    - 而接收端收到RST包后，也不必发送ACK包来确认
  - 没有监听的端口。建立连接的SYN到达某端口，但是该端口上没有正在 监听的服务
  - TCP收到了一个根本不存在的连接上的分节。比如客户端在服务端已经关闭掉socket之后，仍然在发送数据。这时服务端会产生RST
  - 请求超时。 使用setsockopt的SO_RCVTIMEO选项设置recv的超时时间。接收数据超时时，会发送RST包

- 服务器大量处于TIME_WAIT状态，可能的原因，造成什么影响，怎么解决
  - 原因：服务器端主动发出FIN来断开连接
  - 影响：过多的TIME_WAIT造成端口和文件描述符被大量占用，无法建立新的连接
  - 解决：开启timewait的快速回收和重用
  ```
  net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
  net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
  net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
  net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间
  ```
  - 如果以上配置调优后性能还不理想，可继续修改一下配置
  ```
  net.ipv4.tcp_keepalive_time = 1200 
  #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20 分钟。
  net.ipv4.ip_local_port_range = 1024 65000 
  #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。
  net.ipv4.tcp_max_syn_backlog = 8192 
  #表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络  连接数。
  net.ipv4.tcp_max_tw_buckets = 5000 
  #表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接 字将立刻被清除并打印警告信息。
  默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减 少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制  TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。
  ```
- 为什么timewait（两点）
  - 可靠地实现TCP全双工连接的终止。如果服务端没有收到ACK，保持timewait状态可以重传ACK，确保被动端收到以可靠终止连接。
  - 确保老的重复分节在网络中消逝（最大需要等待2MSL）

- 服务器大量处于close_wait的原因，以及怎么处理
  - 原因：服务端忘记关闭socket
  - 处理：检查程序遗漏关闭socket的地方


- UDP怎么实现TCP的拥塞控制？
- UDP可靠传输
  - UDP已经是不可靠的连接，那就要在应用层自己实现一些保障可靠传输的机制
  - 要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传（定时器），有序接受 （添加包序号），有序接受 （添加包序号），滑动窗口流量控制等机制
  - UDT。基于UDP的数据传输协议（UDP-based Data Transfer Protocol，简称UDT）是一种互联网数据传输协议
  - QUIC。QUIC是Google实现的一种可靠UDP传输协议，并且已经被选择作为HTTP/3的基础
  ![](http://images-1251273400.cosgz.myqcloud.com/20201017222506.png)
  - [《基于UDP的数据传输协议（UDP-based Data Transfer Protocol，简称UDT）是一种互联网数据传输协议》](https://blog.csdn.net/ls5718/article/details/52141571)
  - [《可靠UDP传输协议总结》](https://zhuanlan.zhihu.com/p/68466363)
  
- QUIC
  - 为什么要使用QUIC
    - UDP比TCP传输速度快，QUIC是基于UDP实现的可靠协议
    - 其次TCP是系统内核实现的，如果升级TCP协议，就得让用户升级系统，这个的门槛比较高，而QUIC在UPD基础上由客户端自由发挥，只要有服务器能对接就可以
    ![](http://images-1251273400.cosgz.myqcloud.com/20201017224411.png)
  - 连接建立延时低。QUIC只需要一次往返就能建立HTTPS连接
  - 改进的拥塞控制
    - TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复
    - QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法
  - QUIC的NACK比TCP的延迟确认机制高效
  - FEC前向纠正拥塞控制。FEC是Forward Error Correction前向错误纠正的意思，就是通过多发一些冗余的包，当有些包丢失时，可以通过冗余的包恢复出来，而不用重传
  - 切换网络操持连接。QUIC使用一个ID来标志连接，即使切换网络也可以使用之前的建立连接的数据如交换的密钥，而不用再重新HTTPS握手

  - [《浅谈QUIC协议原理与性能分析及部署方案》](https://juejin.im/post/6844904182361636878)

## TCP底层原理
- TCP中的流量控制与拥塞控制
  - 拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复
  - 流量控制。流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的

- 慢开始，拥塞避免算法
  - 初始时把拥塞窗口cwnd设为1（慢开始），然后每次来回只要没有出现超时，cwnd就翻倍
  - 当cwnd超过ssthresh门限值，就转为拥塞避免算法，即每次来回只要没超时，cwnd就+1
  - 如果出现了超时，那么cwnd就立即变成1，同时ssthresh门限值就减半，然后开始执行慢开始
![](http://images-1251273400.cosgz.myqcloud.com/20201017205801.png)
  - [《TCP流量控制、拥塞控制》](https://zhuanlan.zhihu.com/p/37379780)

- 快重传，快恢复算法
  - 快重传。快重传要求接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认；发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期
  ![](http://images-1251273400.cosgz.myqcloud.com/20201017211257.png)
  - 快恢复。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是cwnd不设为1，而是设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。这样做是因为考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞
  ![](http://images-1251273400.cosgz.myqcloud.com/20201017211458.png)


- TCP连接的两方，某一方突然断网了，怎么办，嫌keepalive的时间太长的怎么办？
  - TCP还设有一个保活计时器（keepalive)，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
  - 以通过设置套接字选项将时间设置短一点
  ```
  setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval))
  ```

- 网线断开会发生什么（超时）哪一端会先断开（？）
  - 发送包（心跳包或者数据包）并检测到超时的一方会先感知到断开

- 说说MTU，跟着扩展到网络层分片
- 说一说滑动窗口
- 当滑动窗口为0的时候是因为什么，是对端发生了什么？问：是阻塞在那一层？
- 滑动窗口为什么是字节为单位滑动的？
- 介绍一下拥塞控制，丢包时为什么阈值会减半

- TCP已经有了保活为什么还要有心跳包
- Linux下的Socket编程常用的抓包工具
- tcp黏包问题
- TCP数据包传到IP层会不会发生分包
- tcp超时重传具体多久
- TCP连接的两方，某一方突然断网了，怎么办，嫌keepalive的时间太长的怎么办？回答的应该可以通过设置套接字选项将时间设置短一点
- TCP连接释放连接的过程及状态变化
- TCP头部字节大小多少？UDP呢？
- 将TCP报文段传到网络层要不要分包？
- TCP里多大的数据量传输要进行封装？

- 问了解MMS和MTU吗？知道最大地址MTU吗？


## 网络编程
- 讲一下poll和epoll和select的区别
   - poll是数组， select之类的就是链表，需要用户进程自己轮询复用，epoll是红黑树+链表，返回的链表都是可读的标识符 

- select及epoll的了解，epoll添加一个描述好还是添加多个好
- epoll的机制，什么时候用ET
- epoll水平触发和边沿触发，底层原理
- 说说epoll的数据结构，大致是双链表和RB-Tree

- epoll_wait的最后一个参数是什么意思，如果设置为0会怎样

- 惊群问题

- Linux 下 I/O 复用：select、poll、epoll 高并发
- 你觉得主线程用来Accept好吗？为什么好？我用100个线程来accept不一样吗？你觉得Reactor模式好在哪？

- Reactor反应堆模式

- IO模型有哪些

- 用的最多的应该算IO多路复用模型，讲讲它的优缺点

- listen函数的backlog参数是什么意思；backlog的作用，编程中应该设置为多大
  - linux内核中会维护两个队列： 
    - 1）未完成队列：接收到一个SYN建立连接请求，处于SYN_RCVD状态 
    - 2）已完成队列：已完成TCP三次握手过程，处于ESTABLISHED状态 
  - 当有一个SYN到来请求建立连接时，就在未完成队列中新建一项。当三次握手过程完成后，就将套接口从未完成队列移动到已完成队列。 
  - backlog曾被定义为两个队列的总和的最大值，也曾将backlog的1.5倍作为未完成队列的最大长度，一般将backlog指定为5

- 客户端是是否可以使用bind
- 介绍下libev库（基于事件驱动的高性能库） 什么是reactor模型
- 网络编程的函数调用套路，客户端服务器端（还说了一些连接队列）


- accept函数在面对超过数十个连接过来的时候怎么处理，是一个个处理吗？还是一起处理

## 网络基础

- 数据包从网卡到网卡要经历那些内存拷贝？

- 七层、五层结构

- 讲一下ARP协议

- 知道ARP欺诈吗？

- IP包头中的TTL是什么意思？

- 说说你看过的网络库

- socks5协议流程


## 网络加密
- SSL的原理和过程
- 公钥私钥介绍下
  - RSA基于大质数难以分解
  - 应用SSH ： 验证客户端身份：公钥加密，私钥解密，服务器需要先信任客户端的公钥
  - 校验流程 ： 服务端用公钥加密一段数据，客户端必须用私钥解开
  - 应用 HTTPS : ...
- 非对称加密算法流程；
- 常用签名算法；

## 网络应用题
- LOL，吃鸡这种游戏的网络协议怎么设计？tcp会有哪些地方可能造成延时高
  - 说了流量控制，拥塞控制，nagle算法，丢包等
- 花生壳内网穿透原理
