
[TOC]
## 优秀文章
 - [《操作系统与编译面试题》](https://www.jianshu.com/p/b2ff3117faf1)
 
## 进程&线程
#### 进程
- 常见的进程间通信方式
  - 管道/匿名管道(pipe)。只能用于父子或者兄弟进程之间；本质是一个内核缓冲区
  - 有名管道(FIFO)。本质是一个带路径的文件
  - 信号(Signal)
  - 信号量(semaphore)
  - 消息(Message)队列
  - 共享内存(share memory)
  - 套接字(socket)
  - [《进程间通信IPC》](https://www.jianshu.com/p/c1015f5ffa74)

- 最快的进程间通信方式是什么？
  - 共享内存

- 共享内存为什么比其他的进程间通信方式快？
  - 因为共享内存通过映射mmap的方式直接映射到进程的私有内存空间，进程可以直接对其进行读写
  - 其它方式的通信基本上都是需要借助内核来实现间接通信

- 重启进程后，原共享内存是否可以操作？对于普通的进程又是如何呢？
  - 进程重启共享内存中数据不会丢失，内核自举或调用shmdt或使用ipcrm删除后丢失

- 什么是孤儿进程和僵尸进程？
  - 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作，因此孤儿进程是没有危害的
  - 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程
  - 解决办法：把产生大量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，
  - [《孤儿进程与僵尸进程[总结]》](https://www.cnblogs.com/anker/p/3271773.html)

- 什么是进程, 什么是线程。它们之间的区别和联系
  - 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
  - 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
  - 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
  - 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
  - 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
  - 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
  - [《进程和线程的区别(超详细)》](https://blog.csdn.net/ThinkWon/article/details/102021274)
- 一个程序从开始运行到结束的完整过程
  - 编译
    - 预处理
    - 编译
    - 汇编
  - 目标文件的格式。Linux 下的目标文件格式叫做 ELF（Executable Linkable Format）
    ![](http://images-1251273400.cosgz.myqcloud.com/20201020231023.png)
  - 链接
    - 重定位表。编译器把所有需要被重定位的数据存放在重定位表中，这样链接器就能够知道该目标文件中哪些数据是需要被重定位的
    - 符号表（.symtab）。目标文件中的某些部分是需要在链接的时候被使用到的 “粘合剂”，这些部分我们可以把其称之为 “符号”，符号就保存在符号表中
  - 装载
    - 由于现代操作系统均采用分页的方式来管理内存，所以操作系统只需要读取可执行文件的文件头，之后建立起可执行文件到虚拟内存的映射关系，而不需要真正的将程序载入内存。一旦操作系统创建进程 (fork) 并载入了可执行文件 (exec)，那么虚拟内存的分布应该如下图所示
    ![](http://images-1251273400.cosgz.myqcloud.com/20201020231449.png)
  - 运行
    - 操作系统 jmp 到进程的第一条指令并不是 main 方法，而是别的代码。这些代码负责初始化 main 方法执行所需要的环境并调用 main 方法执行，运行这些代码的函数被称为入口函数或者入口点（Entry Point）
    - 操作系统在创建进程之后，jmp 到这个进程的入口函数
    - 入口函数对程序运行环境进行初始化，包括堆、I/O、线程、全局变量的构造，等等
    - 入口函数在完成初始化之后，调用 main 函数，开始执行程序的主体
    - main 函数执行完毕之后返回到入口函数，入口函数进行清理工作，最后通过系统调用结束进程
  - [《程序的编译、链接、装载与运行》](https://www.nosuchfield.com/2018/11/23/Program-compilation-linking-loading-and-running/)

- 怎么求一个进程可用栈空间的大小
  - ulimit -s 命令查看最大栈大小
  - 可以通过一个无限递归去分配栈空间，来探测可用栈的大小
  ```c++
    #include <stdio.h>

    int i = 1;

    void func(){
    	char arr[1024]; //1k
    	printf("%d ", i);
    	i++;
    	func();
    }

    void main(){
    	func();
    }
  ```
- 进程A和进程B只能进行网络通信，当进程B挂掉之后进程A如何快速知道进程B挂掉？
  - 方法一，A进程定时去获取状态
    - A通过网络通信获取B进程的pid
    - A然后定时调动kill(pid,0)，去获取B进程的状态
  - 方法二，B进程注册进程退出时的回调，退出后通知A进程
  ```c++

  int main(int argc, char *argv[])
  {
      atexit(before_exit);
      signal(SIGTERM, signal_exit_handler);
      signal(SIGINT, signal_exit_handler);
  
      // ignore SIGPIPE
      signal(SIGPIPE, SIG_IGN);
  
      signal(SIGBUS, crash_handler);     // 总线错误
      signal(SIGSEGV, crash_handler);    // SIGSEGV，非法内存访问
      signal(SIGFPE, crash_handler);       // SIGFPE，数学相关的异常，如被0除，浮点溢出，等等
      signal(SIGABRT, crash_handler);     // SIGABRT，由调用 abort函数产生，进程非正常退出
  
      return 0;

  ```
- 调用fork，发生了些什么事情
  - 发起_fork()系统调用，控制权由用户态转为内核态
  - 内核会分配新的内存块和内核数据结构给子进程（也就是PCB task_struct结构体）
  - 内核会将父进程的部分数据内容以二进制形式拷贝到子进程
  - 将所谓的子进程PCB加入到管理链表中（操作系统管理进程就是将程序用PCB描述，用链式结构进行管理）
  - 从内核态返回用户态（父进程fork返回进程pid，子进程返回0）
  - 开始调度器调度
  - 子进程刚被创建出来，父子进程不再写入的时候，父子进程是数据共享一份，代码独有，但是当有任意一方试图写入数据的时候，便已写时拷贝的方式各自拥有一份数据，这就是所谓的写时拷贝。
  - [《fork（）之后，发生了什么》](https://blog.csdn.net/Luckyboom_/article/details/99608525)

- 一个进程里包含什么？进程拥有的资源有那些？
  - 线程共享的环境
    - 1.进程代码段 
    - 2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) 
    - 3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。
  - 线程独立的资源
    - 线程ID
    - 寄存器组的值
    - 线程的堆栈
    - 线程的堆栈
    - 线程的信号屏蔽码
    - 线程的优先级
  - [《进程？线程？到底共享了什么私有了什么》](https://blog.csdn.net/WangQYoho/article/details/52598859)

- 一个进程在32系统上寻址空间最多多大？
  - linux下内核空间占用1G，进程空间3G，抛去代码，栈，全局变量等占用的空间，进程还能使用的空间大概有2G多

- 父进程和子进程在内存上的关系？
  - 采用了写时复制技术。刚fork完之后，父子进程页表是相同的，指向了相同的内容，只有当子进程写入内容时，才开始拷贝一份独立的内存开始写入

- 多进程和多线程会有什么区别？可能出现什么问题
  ![](http://images-1251273400.cosgz.myqcloud.com/20201021223051.png)
  ![](http://images-1251273400.cosgz.myqcloud.com/20201021223130.png)
  ![](http://images-1251273400.cosgz.myqcloud.com/20201021223146.png)
  - [《面试总结，多进程和多线程的区别》](https://blog.csdn.net/linraise/article/details/12979473)

- 进程切换怎么实现 怎么保留断点信息
  - 用户级上下文。程序代码、数据、用户堆栈以及共享存储区
  - 寄存器上下文。通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)
  - 系统级上下文。进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈
  - [《Linux下的进程1——进程概念，进程切换，上下文切换，虚拟地址空间》](https://blog.csdn.net/lixungogogo/article/details/52202714)

- 进程的几个状态？进程状态转换
  ![](http://images-1251273400.cosgz.myqcloud.com/20201021224242.png)
  - 1）就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；
  - 2）执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； 
  - 3）阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；
  - 4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态
  - [《进程的有哪几种状态，状态转换图，及导致转换的事件》](https://blog.csdn.net/xieyutian1990/article/details/38402977)

- - Linux 进程环境：僵尸进程、孤儿进程、守护进程、进程组、会话、前台进程组、后台进程组
  - 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作
  - 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程
  - Linux Daemon（守护进程）。是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等
  - 进程组。引入进程组的概念，可以更方便地管理一组进程。比如一项工作放弃了，不必向每个进程一一发送信号，可以直接将信号发送给进程组，进程组内的所有进程都会收到该信号
  - 会话。会话是一个或多个进程组的集合，会话的意义在于将很多的工作囊括在一个终端，选取其中一个作为前台来直接接收终端的输入及信号，其他的工作则放在后台执行
  ![](http://images-1251273400.cosgz.myqcloud.com/20201021224915.png)
  - [《守护进程详解及创建，daemon()使用》](https://www.cnblogs.com/mickole/p/3188321.html)
  - [《linux之进程的基本概念(进程，进程组，会话关系）》](https://blog.csdn.net/caoshangpa/article/details/80140888)

- 编写守护进程
![](http://images-1251273400.cosgz.myqcloud.com/20201021225141.png)
```c++
pid_t pid, sid;
int i;
openlog("daemon_syslog", LOG_PID, LOG_DAEMON);
pid = fork(); // 第1步
if (pid < 0) exit(-1);
else if (pid > 0) exit(0);  // 父进程第一次退出
if ((sid = setsid()) < 0)   // 第2步
{
    syslog(LOG_ERR, "%s\n", "setsid");
    exit(-1);
}
// 第3步 第二次父进程退出
if ((pid = fork()) > 0) exit(0);
if ((sid = chdir("/")) < 0) // 第4步
{
    syslog(LOG_ERR, "%s\n", "chdir");
    exit(-1);
}
umask(0); // 第5步
// 第6步：关闭继承的文件描述符
for(i = 0; i < getdtablesize(); i++)
{
    close(i);
}
while(1)
{
    do_something();
}
closelog();
exit(0);
```

- 在main函数中定义了a和b两个int变量，调用sum函数求其和，说一下其压栈过程
  - b入栈
  - a入栈
  - 返回地址（即函数调用的下一条指令地址）入栈
  - 调用者的ebp入栈
  - 最后设置新的ebp和esp指针，正式进入sum函数
![](http://images-1251273400.cosgz.myqcloud.com/20201022223224.png)
  - [C函数调用过程原理及函数栈帧分析](https://segmentfault.com/a/1190000007977460)

- Linux共享库的概念和意义？
  - 命名规则：lib+动态库名称+.so+.+版本号;比如libC++.so.6
  - 动态函数库在编译的时候并没有被编译进目标代码中;在运行时，由系统的动态函数库"lib/ld.so"负责动态加载
  - 优点
    - 减小应用程序的体积
    - 方便共享库被多个程序共用，减少内存使用
    - 方便动态升级，实现热升级
  - 隐式调用。使用方便简单, 但其和静态库相似, 在编译期就和程序绑定了,灵活性差, 并且其生存期和进程一样, 进程开始, 调用开始, 进程结束, 动态库才卸载. 另外还需要将整个动态库全部加进内存.
  - 显式调用。使用起来比较复杂, 但是却可以在运行期间选择所需要调用的动态链接库, 并且可以控制动态库生存期, 需要加载时候再加载, 用完了就可以卸掉, 而且不用将整个动态库都放进内存, 只要加载要用到的函数即可
    - dlopen。打开动态链接库
    - dlsym。查找符号表,定位共享函数
    - dlclose。关闭共享库
  - [《linux共享库》](https://www.jianshu.com/p/4452ae231000)

- -fpic位置无关代码是什么
  - 位置无关代码在数据段开始为每一个全局符号保留了一个条目（GOT global offset table），每一个条目中保存了全局符号的绝对地址（这个绝对地址，在动态链接库装载的时候被填写）
  - 代码中每次对动态链接中全局符号的引用，首先找到GOT中的条目，然后获得全局符号的地址，这样就实现了位置无关代码
  - 位置无关代码就是引用了GOT这样一个中间层，来保证代码不用改变
  - [《动态链接与位置无关代码》](https://zhuanlan.zhihu.com/p/20832831)
  
#### 线程
- 线程栈通常是多少
  - 通过ulimit -s查看，一般是8M

- 进程栈与线程栈
  - 进程栈大小时执行时确定的，与编译链接无关

  - 进程栈大小是随机确认的，至少比线程栈要大，但不会超过2倍

  - 线程栈是固定大小的，可以使用ulimit -a 查看，使用ulimit -s 修改

  - 一般默认情况下，线程栈是在进程的堆中分配栈空间，每个线程拥有独立的栈空间，为了避免线程之间的栈空间踩踏，线程栈之间还会有以小块guardsize用来隔离保护各自的栈空间，一旦另一个线程踏入到这个隔离区，就会引发段错误。

- 线程间通信与同步方式
  - 全局变量（volatile)
  - 线程间同步主要有互斥量、读写锁、条件变量、自旋锁、屏障
  - [《Linux线程间同步 —— 5种方式简介》](https://blog.csdn.net/electrocrazy/article/details/78931704)
  - [《线程间的通信、同步方式与进程间通信方式》](https://www.jianshu.com/p/9218692cb209)

- 那一个线程可以访问另一个线程的线程栈吗，会发生什么
  - 可以。不过由于栈空间随时改变或者释放，可能访问到脏数据甚至越界访问导致程序挂掉

- 假设有两个线程，一个线程怎么了解到另外一个线程是否崩溃
  - 线程挂掉会导致进程也挂掉，因此同一进程下的线程没有机会了解到另一个进程是否挂掉

- 线程安全队列该怎么实现，说了一下生产者消费者模型
  - c++中使用条件变量来实现安全队列
  - [《C++ 并发编程（五）：生产者 - 消费者》](https://segmentfault.com/a/1190000006703543)

- 多线程如何实现同步与互斥，针对一个问题具体讲一下怎么用
  - 用户模式下：原子操作（例如一个单一的全局变量），临界区
  - 内核模式下的方法有：事件，信号量，互斥量，条件变量
  - 同步，是指在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行
  - 互斥。指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的
  - [《多线程同步和互斥有哪几种实现方法》](https://blog.csdn.net/mpp_king/article/details/80090120)
- 如何调整多线程的负载均衡？

- 线程栈的大小，能调整吗？代码中怎么调整？
  - pthread_attr_setstacksize接口来修改线程栈的大小

- fork，vfork，clone的关系，clone是为了创建线程的吗？
  - fork，vfork，__clone都调用clone，也就是说，在现代操作系统，fork是clone实现的，它们各具各自需要的参数标志调用clone，clone又调用do_fork()
  - fork被调用时，复制父进程的页表，创建新的进程描述符task_struct，新创建的进程与父进程对地址空间的关系为 “写时复制” 当进程写数据到地址空间时就重新开辟一块内存来存放新结果
  - vfork与fork的区别仅仅是不复制页表，调用vfork之后，父进程会挂起，子进程无法写入，直到子进程结束或者调用exec
  - clone系统调用就是一个创建轻量级进程的系统调用
  ![](http://images-1251273400.cosgz.myqcloud.com/20201024222855.png)
  ```
  为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的房子了，这时候就相 于分家了
  ```
  - [《fork，vfork, clone的区别和关系》](https://blog.csdn.net/t782665933/article/details/90273001)
  - [《clone的fork与pthread_create创建线程有何不同》](https://blog.csdn.net/swartz_lubel/article/details/77809365)
  - [《fork与vfork的区别》](https://blog.csdn.net/jianchi88/article/details/6985326)

#### 协程

- 协程怎么切换，具体到寄存器
  - 切换简要说明
    - 保存当前协程的上下文（运行栈，返回地址，寄存器状态）
    - 设置将要唤醒的协程的入口指令地址到IP寄存器
    - 恢复将要唤醒的协程的上下文
  ```
  %rax作为函数返回值使用；%rsp栈指针寄存器，指向栈顶；

  %rdi,%rsi,%rdx,%rcx,%r8,%r9包含最多6个参数，依次对应第1、2、3…参数，当参数超过6个，会通过压栈的方式传参数；

  %rbx,%rbp,%r12,%r13,%r14,%r15用作数据存储，遵循被调用者使用规则，调用子函数之前要备份它，以防他被修改；

  %r10,%r11 用作数据存储，遵循调用者使用规则，使用之前要先保存原值  
  ```
  - [《进程和协程切换原理及实现》]()

## 锁
- 互斥锁，自旋锁，读写锁，悲观锁/乐观锁
  - 互斥锁加锁失败后，线程会释放 CPU ，给其他线程
  - 自旋锁加锁失败后，线程会忙等待，直到它拿到锁
  - 读写锁适用于能明确区分读操作和写操作的场景。读写锁在读多写少的场景，能发挥出优势
    - 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
    - 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞
  - 互斥锁、自旋锁、读写锁，都是属于悲观锁
  - 悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁
  - 乐观锁全程并没有加锁，所以它也叫无锁编程
  - [《面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景》](https://www.cnblogs.com/xiaolincoding/p/13675202.html)
  
- 什么时候会发生死锁
  - 死锁的条件
    - 互斥条件：每个资源都被分配给了一个进程或者资源是可用的
    - 保持和等待条件：已经获取资源的进程被认为能够获取新的资源
    - 不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放
    - 循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源

- 在代码实现上怎么解决死锁呢
    - 破坏互斥条件
      - 如果资源不被一个进程独占，那么死锁肯定不会产生
    - 破坏保持等待的条件
      - 让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待
      - 进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源
    - 破坏不可抢占条件
      - 破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况
    - 破坏循环等待条件
      - 制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源
      - 给资源编号，请求资源的顺序必须按照编号的顺序来请求
    - [《写给大忙人看的死锁全详解》](https://www.cnblogs.com/cxuanBlog/p/13202898.html)

- 什么是死锁 怎样避免（超时锁 和 银行家算法） 简述银行家算法
  - 超时锁  -- 破坏保持等待
  - 银行家算法  -- 破坏循环等待
    - 当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待
  - [《一句话+一张图说清楚——银行家算法》](https://blog.csdn.net/qq_33414271/article/details/80245715)

- 有些线程处于死锁状态了，怎么在另一个线程中检测出来


- 自旋锁是什么，怎么实现的
  - 自旋锁是利用CAS实现的
  - lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁
  - [《面试必备之深入理解自旋锁》](https://zhuanlan.zhihu.com/p/40729293)
  ```java
  public class SpinLock {
    private AtomicReference<Thread> cas = new AtomicReference<Thread>();
    public void lock() {
        Thread current = Thread.currentThread();
        // 利用CAS
        while (!cas.compareAndSet(null, current)) {
            // DO nothing
        }
    }
    public void unlock() {
        Thread current = Thread.currentThread();
        cas.compareAndSet(current, null);
    }
  }
  ```

- 解释生产者消费者模型
  - 生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞
  - [《C++ 并发编程（五）：生产者 - 消费者》](https://segmentfault.com/a/1190000006703543)

## 内存
- linux内核内存管理方法
  -  Linux内核是通过2种方法来管理内存的：在需要大块内存分配的时候， 使用buddy（伙伴）算法来分配， 在需要小块内存的时候使用slab/slub高速缓存系统来分配。Buddy是内存管理的最上层结构， 它分配若干个连续的物理内存页， 一个物理页大小为4kb， 也是说通过Buddy系统分配得到的内存最少是4kb，它管理的是大内存块。Slab基于Buddy， 将一个物理内存页分成若干小块进行管理， 所以slab用于管理小块
![](http://images-1251273400.cosgz.myqcloud.com/20201025102527.png)
  - Buddy伙伴分配算法
    - 管理的对象是内存页
    - 把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。最大可以申请1024个连续页框，对应4MB大小的连续内存。每个页框块的第一个页框的物理地址是该块大小的整数倍
    - 分配内存。假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了则将页框块分为2个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中
    - 释放内存。页框块在释放时，会主动将两个连续的页框块合并为一个较大的页框块
    - ![](http://images-1251273400.cosgz.myqcloud.com/20201025103658.png)
  - Slab
    - slab分配器分配内存以Byte为单位，用于管理小内存的分配
    - slab分配器并没有脱离伙伴系统，而是基于伙伴系统分配的大内存进一步细分成小内存分配
    - kmem_cache是一个cache_chain的链表，描述了一个高速缓存，每个高速缓存包含了一个slabs的列表
    - 存在3种slab。slabs_full(完全分配的slab)；slabs_partial(部分分配的slab)；slabs_empty(空slab,或者没有对象被分配)
    ![](http://images-1251273400.cosgz.myqcloud.com/20201025104154.png)
  
  - [《Linux内核内存管理算法Buddy和Slab》](https://zhuanlan.zhihu.com/p/36140017)
  - [《物理内存管理系统设计与实现》](https://developer.aliyun.com/article/1744)

- 物理地址空间布局
  - Linux内核将所有的物理页面划分到3类内存管理区中，如图，分别为ZONE_DMA，ZONE_NORMAL，ZONE_HIGHMEM
  - ZONE_DMA 的范围是 0~16M，该区域的物理页面专门供 I/O 设备的 DMA 使用。之所以需要单独管理 DMA 的物理页面，是因为 DMA 使用物理地址访问内存，不经过 MMU，并且需要连续的缓冲区，所以为了能够提供物理上连续的缓冲区，必须从物理地址空间专门划分一段区域用于 DMA。
  - ZONE_NORMAL 的范围是 16M~896M，该区域的物理页面是内核能够直接使用的。
  - ZONE_HIGHMEM 的范围是 896M~结束，该区域即为高端内存，内核不能直接使用
  ![](http://images-1251273400.cosgz.myqcloud.com/20201025104859.png)
  - [《物理地址和虚拟地址的分布》](https://zhuanlan.zhihu.com/p/36139988)

- linux虚拟空间布局（包括内核空间和虚拟空间）
  - ![](http://images-1251273400.cosgz.myqcloud.com/20201025105351.png)
  - 虚拟空间与物理空间的映射
    - 内核将 0~896M 的物理地址空间一对一映射到自己的线性地址空间中，这样它便可以随时访问 ZONE_DMA 和 ZONE_NORMAL 里的物理页面
    - 内核剩下的 128M 线性地址空间不足以完全映射所有的 ZONE_HIGHMEM，Linux 采取了动态映射的方法，即按需的将 ZONE_HIGHMEM 里的物理页面映射到 kernel space 的最后 128M 线性地址空间里，使用完之后释放映射关系，以供其它物理页面映射
  ![](http://images-1251273400.cosgz.myqcloud.com/20201025105957.png)
  - [《物理地址和虚拟地址的分布》](https://zhuanlan.zhihu.com/p/36139988)

- 虚拟内存与物理内存

- vmalloc和kmalloc，malloc区别 
  -  kmalloc申请的是较小的连续的物理内存，虚拟地址上也是连续的。kmalloc和get_free_page最终调用实现是相同的，只不过在调用最终函数时所传的flag不同而已。除非被阻塞否则他执行的速度非常快，而且不对获得空间清零。
  - get_free_page()申请的内存是一整页，一页的大小一般是128K。
  - kzalloc 先是用 kmalloc() 申请空间 , 然后用 memset() 清零来初始化 ,所有申请的元素都被初始化为 0.
  - vmalloc用于申请较大的内存空间，虚拟内存是连续，但是在物理上它们不要求连续。
  - malloc 用于用户空间申请内存。除非被阻塞否则他执行的速度非常快，而且不对获得空间清零。
  ![](http://images-1251273400.cosgz.myqcloud.com/20201025112057.png)
  - [《linux内存管理之malloc、vmalloc、kmalloc的区别
》](https://www.cnblogs.com/alantu2018/p/9000778.html)

- malloc分配的是虚拟内存还是物理内存？
  - 虚拟内存
  - malloc将可用的内存块连接为一个长长的列表的所谓空闲链表(全局变量，一个内存块的链表指针)。
  - 调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。
  - 调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块

- memset操作malloc的指针，是操作物理内存还是虚拟内存？
  - 虚拟内存

- 共享内存和mmap的区别
  - mmap将一个文件fd映射到用户内存空间
  ![](http://images-1251273400.cosgz.myqcloud.com/20201025113931.png)
  - 共享内存将一段物理内存映射到用户空间
  ![](http://images-1251273400.cosgz.myqcloud.com/20201025114020.png)
  - mmap是在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间进行映射。
  - shm每个进程最终会映射到同一块物理内存。shm保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大。
  - 相对于shm来说，mmap更加简单，调用更加方便；另外当机器重启后，因为mmap把文件保存在磁盘上，这个文件还保存了操作系统同步的映像，所以mmap不会丢失，但是shmget就会丢失
  - [《mmap映射区和shm共享内存的区别总结》](https://blog.csdn.net/hj605635529/article/details/73163513)

- 了解共享内存吗（说了下虚拟页面到物理页帧的映射），后问如果这两个进程都终止了，共享内存还在吗
  - 还在
  - 当再也没有进程需要使用这个共享内存块的时候，必须有一个（且只能是一个）进程负责释放这个被共享的内存页面
  ```
  （1）通过int shmget(key_t key, size_t size, int shmflg);在物理内存创建一个共享内存，返回共享内存的编号。
  （2）通过void *shmat(int shmid, constvoid shmaddr,int shmflg);连接成功后把共享内存区对象映射到调用进程的地址空间
  （3）通过void *shmdt(constvoid* shmaddr);断开用户级页表到共享内存的那根箭头。
  （4）通过int shmctl(int shmid, int cmd, struct shmid_ds* buf);释放物理内存中的那块共享内存
  ```

- 内存4G，malloc申请4.1G会发生什么
  - 申请失败
  - malloc能够申请的内存空间大概在2G左右

- 一堆内存碎片。此时要分配一个大空间。可以分配吗（内存碎片加起来的空间大于要申请的空间）
    - malloc会尝试将相邻的小空闲块合并成较大的内存块

- 缓存淘汰算法。
  - 缓存算法（页面置换算法）FIFO、LFU、LRU
  - FIFO，先进先出。如果一个数据最先进入缓存中，则应该最早淘汰掉
  - LFU（Least Frequently Used），最近最少使用算法。如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小
  - LRU，最近最久未使用
  - [《（操作系统）缓存算法》](https://juejin.im/post/6844904161239121934)

- 调用malloc时会立即分配物理内存吗
  - malloc不会立即分配物理内存，只有使用时触发缺页中断才会分配物理内存


## 中断，信号，内核态，定时器，以及各种数据结构实现原理
- 什么是中断,中断处理流程,缺页中断

- 用户态和内核态 系统调用能不能进入内核态

- 定时器为什么要用最小堆；定时器除了小根堆，还可以怎么做
  - 由于定时器的触发是由于时间到了，因此只有时间最短的定时器会首先被触发，通过这个原理，我们可以采用最小堆，将按时间顺序排序，堆顶元素是时间最短的定时器，因此只要判断堆顶元素是否被触发即可。只有堆顶定时器的时间到了，才会到其他时间较晚的定时器的时间

- 定时器的几种实现
  - 双向有序链表
  ```
  插入：O(N)  //插入排序
  取消：O(1)  
  运行：O(1)  //取最前面的运行
  ```
  - 最小堆
  ```
  插入：O(logN)
  取消：O(logN)
  运行：O(1)  //取堆顶元素运行
  ```
  - 多级时间轮
    - 实现一个 最小刻度为毫秒，最大刻度为天 的定时器（最长延时23点59分59秒999毫秒）
    - 在 3点30分25秒600毫秒 处安插一个 tick
    - 这个实现需要用到4个轮，时（24），分（60），秒（60），毫秒（1000）总插槽数为 1144 = 24 + 60 + 60 + 1000
    - 首先在 时(3) 安插上这个 tick，当执行到 时(3) 的时候，删除这个 tick，检查到该 tick 还有 30分25秒600毫秒。
    - 于是在 分（30） 安插上这个 tick，当执行到 分（30） 的时候，删除这个 tick，检查到该 tick 还有 25秒600毫秒。
    - 于是在 秒（25） 安插上这个 tick，依次类推
  - [《算法 & 数据结构——时间轮定时器》](https://www.jianshu.com/p/4c270f81ff22)

- 实现时间跨度为一天的定时器，插入时间复杂度O(1)，定时不需要很精确
  - 多级时间轮，见上一题的解法
  
- 信号实现原理

- 管道通信相关操作和实现？
- 未命名管道和命名管道的区别

- 解释一下内存池的概念
- 原子操作了解吗

- 缓冲区实现，为什么不使用循环队列

- 库函数和系统调用区别
- Linux写时复制技术

- 调度算法
- linux中CPU调度怎么做的
- Round-robin介绍一下

- 文件系统的inode，硬链接与软连接。


## 程序编译&链接

- 编译和链接了解吗？

- 静态链接库和动态链接库的区别

- 调用动态链接库时，加载到内存的哪一段

- 写一个没有main函数的代码，能够运行起来
  - _start，用nostartfiles编译



